Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "STATIC" was declared but never used
Warning: Terminal "CLASS" was declared but never used
Warning: Terminal "COLON" was declared but never used
Warning: Terminal "EXTENDS" was declared but never used
Warning: Non terminal "ArrayOrVarMember" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
  Checking for non-reduced productions...
*** Production "Label ::= IDENT " never reduced
Writing parser...
===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [$START ::= (*) Program EOF , {EOF }]
  [Program ::= (*) PROGRAM ProgramName Namespace DeclarationList LBRACE MethodsDeclarationList RBRACE , {EOF }]
}
transition on PROGRAM to state [2]
transition on Program to state [1]

-------------------
lalr_state [1]: {
  [$START ::= Program (*) EOF , {EOF }]
}
transition on EOF to state [218]

-------------------
lalr_state [2]: {
  [ProgramName ::= (*) IDENT , {error CONST NAMESPACE LBRACE IDENT }]
  [Program ::= PROGRAM (*) ProgramName Namespace DeclarationList LBRACE MethodsDeclarationList RBRACE , {EOF }]
}
transition on IDENT to state [4]
transition on ProgramName to state [3]

-------------------
lalr_state [3]: {
  [Namespace ::= (*) , {error CONST LBRACE IDENT }]
  [Namespace ::= (*) NAMESPACE NamespaceName LBRACE DeclarationList LBRACE MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
  [Program ::= PROGRAM ProgramName (*) Namespace DeclarationList LBRACE MethodsDeclarationList RBRACE , {EOF }]
}
transition on Namespace to state [6]
transition on NAMESPACE to state [5]

-------------------
lalr_state [4]: {
  [ProgramName ::= IDENT (*) , {error CONST NAMESPACE LBRACE IDENT }]
}

-------------------
lalr_state [5]: {
  [Namespace ::= NAMESPACE (*) NamespaceName LBRACE DeclarationList LBRACE MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
  [NamespaceName ::= (*) IDENT , {LBRACE }]
}
transition on NamespaceName to state [211]
transition on IDENT to state [210]

-------------------
lalr_state [6]: {
  [DeclarationList ::= (*) DeclarationList Declaration , {error CONST LBRACE IDENT }]
  [Program ::= PROGRAM ProgramName Namespace (*) DeclarationList LBRACE MethodsDeclarationList RBRACE , {EOF }]
  [DeclarationList ::= (*) , {error CONST LBRACE IDENT }]
}
transition on DeclarationList to state [7]

-------------------
lalr_state [7]: {
  [ConstDeclaration ::= (*) CONST Type ConstDeclarationList , {SEMICOLON }]
  [DeclarationList ::= DeclarationList (*) Declaration , {error CONST LBRACE IDENT }]
  [Declaration ::= (*) VarDeclaration SEMICOLON , {error CONST LBRACE IDENT }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [VarDeclaration ::= (*) error , {SEMICOLON }]
  [Program ::= PROGRAM ProgramName Namespace DeclarationList (*) LBRACE MethodsDeclarationList RBRACE , {EOF }]
  [Declaration ::= (*) ConstDeclaration SEMICOLON , {error CONST LBRACE IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclaration ::= (*) Type VarList , {SEMICOLON }]
}
transition on IDENT to state [15]
transition on VarDeclaration to state [14]
transition on error to state [13]
transition on Type to state [12]
transition on Declaration to state [11]
transition on LBRACE to state [10]
transition on CONST to state [9]
transition on ConstDeclaration to state [8]

-------------------
lalr_state [8]: {
  [Declaration ::= ConstDeclaration (*) SEMICOLON , {error CONST LBRACE IDENT }]
}
transition on SEMICOLON to state [209]

-------------------
lalr_state [9]: {
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [ConstDeclaration ::= CONST (*) Type ConstDeclarationList , {SEMICOLON }]
  [Type ::= (*) IDENT , {IDENT }]
}
transition on IDENT to state [15]
transition on Type to state [201]

-------------------
lalr_state [10]: {
  [MethodsDeclarationList ::= (*) MethodsDeclarationList MethodDeclaration , {VOID RBRACE IDENT }]
  [Program ::= PROGRAM ProgramName Namespace DeclarationList LBRACE (*) MethodsDeclarationList RBRACE , {EOF }]
  [MethodsDeclarationList ::= (*) , {VOID RBRACE IDENT }]
}
transition on MethodsDeclarationList to state [27]

-------------------
lalr_state [11]: {
  [DeclarationList ::= DeclarationList Declaration (*) , {error CONST LBRACE IDENT }]
}

-------------------
lalr_state [12]: {
  [VarListElement ::= (*) IDENT VarOrArray , {SEMICOLON COMMA }]
  [VarList ::= (*) VarList COMMA VarListElement , {SEMICOLON COMMA }]
  [VarDeclaration ::= Type (*) VarList , {SEMICOLON }]
  [VarList ::= (*) VarListElement , {SEMICOLON COMMA }]
}
transition on VarList to state [21]
transition on IDENT to state [20]
transition on VarListElement to state [19]

-------------------
lalr_state [13]: {
  [VarDeclaration ::= error (*) , {SEMICOLON }]
}

-------------------
lalr_state [14]: {
  [Declaration ::= VarDeclaration (*) SEMICOLON , {error CONST LBRACE IDENT }]
}
transition on SEMICOLON to state [18]

-------------------
lalr_state [15]: {
  [Type ::= IDENT (*) DOUBLE_COLON IDENT , {LPAREN LBRACK IDENT }]
  [Type ::= IDENT (*) , {LPAREN LBRACK IDENT }]
}
transition on DOUBLE_COLON to state [16]

-------------------
lalr_state [16]: {
  [Type ::= IDENT DOUBLE_COLON (*) IDENT , {LPAREN LBRACK IDENT }]
}
transition on IDENT to state [17]

-------------------
lalr_state [17]: {
  [Type ::= IDENT DOUBLE_COLON IDENT (*) , {LPAREN LBRACK IDENT }]
}

-------------------
lalr_state [18]: {
  [Declaration ::= VarDeclaration SEMICOLON (*) , {error CONST LBRACE IDENT }]
}

-------------------
lalr_state [19]: {
  [VarList ::= VarListElement (*) , {SEMICOLON COMMA }]
}

-------------------
lalr_state [20]: {
  [VarListElement ::= IDENT (*) VarOrArray , {RPAREN SEMICOLON COMMA }]
  [VarOrArray ::= (*) , {RPAREN SEMICOLON COMMA }]
  [VarOrArray ::= (*) LBRACK RBRACK , {RPAREN SEMICOLON COMMA }]
}
transition on LBRACK to state [25]
transition on VarOrArray to state [24]

-------------------
lalr_state [21]: {
  [VarDeclaration ::= Type VarList (*) , {SEMICOLON }]
  [VarList ::= VarList (*) COMMA VarListElement , {SEMICOLON COMMA }]
}
transition on COMMA to state [22]

-------------------
lalr_state [22]: {
  [VarListElement ::= (*) IDENT VarOrArray , {SEMICOLON COMMA }]
  [VarList ::= VarList COMMA (*) VarListElement , {SEMICOLON COMMA }]
}
transition on IDENT to state [20]
transition on VarListElement to state [23]

-------------------
lalr_state [23]: {
  [VarList ::= VarList COMMA VarListElement (*) , {SEMICOLON COMMA }]
}

-------------------
lalr_state [24]: {
  [VarListElement ::= IDENT VarOrArray (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [25]: {
  [VarOrArray ::= LBRACK (*) RBRACK , {RPAREN SEMICOLON COMMA }]
}
transition on RBRACK to state [26]

-------------------
lalr_state [26]: {
  [VarOrArray ::= LBRACK RBRACK (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [27]: {
  [MethodDeclaration ::= (*) MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
  [Program ::= PROGRAM ProgramName Namespace DeclarationList LBRACE MethodsDeclarationList (*) RBRACE , {EOF }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [MethodDeclarationTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [Type ::= (*) IDENT , {IDENT }]
  [MethodDeclarationTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodsDeclarationList ::= MethodsDeclarationList (*) MethodDeclaration , {VOID RBRACE IDENT }]
}
transition on VOID to state [32]
transition on MethodDeclarationTypeAndName to state [31]
transition on IDENT to state [15]
transition on RBRACE to state [30]
transition on MethodDeclaration to state [29]
transition on Type to state [28]

-------------------
lalr_state [28]: {
  [MethodDeclarationTypeAndName ::= Type (*) IDENT , {LPAREN }]
}
transition on IDENT to state [200]

-------------------
lalr_state [29]: {
  [MethodsDeclarationList ::= MethodsDeclarationList MethodDeclaration (*) , {VOID RBRACE IDENT }]
}

-------------------
lalr_state [30]: {
  [Program ::= PROGRAM ProgramName Namespace DeclarationList LBRACE MethodsDeclarationList RBRACE (*) , {EOF }]
}

-------------------
lalr_state [31]: {
  [MethodDeclaration ::= MethodDeclarationTypeAndName (*) LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
}
transition on LPAREN to state [34]

-------------------
lalr_state [32]: {
  [MethodDeclarationTypeAndName ::= VOID (*) IDENT , {LPAREN }]
}
transition on IDENT to state [33]

-------------------
lalr_state [33]: {
  [MethodDeclarationTypeAndName ::= VOID IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [34]: {
  [Parameter ::= (*) Type VarListElement , {RPAREN COMMA }]
  [FormPars ::= (*) error , {RPAREN }]
  [FormParsList ::= (*) Parameter , {RPAREN COMMA }]
  [FormPars ::= (*) , {RPAREN }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN (*) FormPars RPAREN VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
  [FormParsList ::= (*) FormParsList COMMA Parameter , {RPAREN COMMA }]
  [FormPars ::= (*) FormParsList , {RPAREN }]
  [Type ::= (*) IDENT , {IDENT }]
}
transition on Parameter to state [39]
transition on IDENT to state [15]
transition on FormPars to state [38]
transition on FormParsList to state [37]
transition on error to state [36]
transition on Type to state [35]

-------------------
lalr_state [35]: {
  [VarListElement ::= (*) IDENT VarOrArray , {RPAREN COMMA }]
  [Parameter ::= Type (*) VarListElement , {RPAREN COMMA }]
}
transition on IDENT to state [20]
transition on VarListElement to state [199]

-------------------
lalr_state [36]: {
  [FormPars ::= error (*) , {RPAREN }]
}

-------------------
lalr_state [37]: {
  [FormParsList ::= FormParsList (*) COMMA Parameter , {RPAREN COMMA }]
  [FormPars ::= FormParsList (*) , {RPAREN }]
}
transition on COMMA to state [197]

-------------------
lalr_state [38]: {
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars (*) RPAREN VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
}
transition on RPAREN to state [40]

-------------------
lalr_state [39]: {
  [FormParsList ::= Parameter (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [40]: {
  [VarDeclaration ::= (*) error , {SEMICOLON }]
  [VarDeclarationListOptional ::= (*) VarDeclaration SEMICOLON VarDeclarationListOptional , {LBRACE }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [VarDeclaration ::= (*) Type VarList , {SEMICOLON }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclarationListOptional ::= (*) , {LBRACE }]
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars RPAREN (*) VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
}
transition on IDENT to state [15]
transition on VarDeclaration to state [42]
transition on VarDeclarationListOptional to state [41]
transition on error to state [13]
transition on Type to state [12]

-------------------
lalr_state [41]: {
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional (*) LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
}
transition on LBRACE to state [45]

-------------------
lalr_state [42]: {
  [VarDeclarationListOptional ::= VarDeclaration (*) SEMICOLON VarDeclarationListOptional , {LBRACE }]
}
transition on SEMICOLON to state [43]

-------------------
lalr_state [43]: {
  [VarDeclarationListOptional ::= VarDeclaration SEMICOLON (*) VarDeclarationListOptional , {LBRACE }]
  [VarDeclaration ::= (*) error , {SEMICOLON }]
  [VarDeclarationListOptional ::= (*) VarDeclaration SEMICOLON VarDeclarationListOptional , {LBRACE }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [VarDeclaration ::= (*) Type VarList , {SEMICOLON }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclarationListOptional ::= (*) , {LBRACE }]
}
transition on IDENT to state [15]
transition on VarDeclaration to state [42]
transition on VarDeclarationListOptional to state [44]
transition on error to state [13]
transition on Type to state [12]

-------------------
lalr_state [44]: {
  [VarDeclarationListOptional ::= VarDeclaration SEMICOLON VarDeclarationListOptional (*) , {LBRACE }]
}

-------------------
lalr_state [45]: {
  [Statements ::= (*) Statements Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statements ::= (*) , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE (*) Statements RBRACE , {VOID RBRACE IDENT }]
}
transition on Statements to state [46]

-------------------
lalr_state [46]: {
  [Statement ::= (*) DesignatorStatement SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Statement ::= (*) LBRACE Statements RBRACE , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON }]
  [Statement ::= (*) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) CONTINUE SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE Statements (*) RBRACE , {VOID RBRACE IDENT }]
  [Statement ::= (*) FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statements ::= Statements (*) Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) BREAK SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON }]
  [Statement ::= (*) IF LPAREN Condition RPAREN Statement ElseOptional , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) RETURN ExprOptional SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Var to state [61]
transition on BREAK to state [60]
transition on RBRACE to state [59]
transition on CONTINUE to state [58]
transition on RETURN to state [57]
transition on LBRACK to state [56]
transition on PRINT to state [55]
transition on DesignatorStatement to state [54]
transition on Statement to state [53]
transition on IF to state [52]
transition on Designator to state [51]
transition on FOR to state [50]
transition on IDENT to state [49]
transition on LBRACE to state [48]
transition on READ to state [47]

-------------------
lalr_state [47]: {
  [Statement ::= READ (*) LPAREN Designator RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on LPAREN to state [193]

-------------------
lalr_state [48]: {
  [Statements ::= (*) Statements Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= LBRACE (*) Statements RBRACE , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statements ::= (*) , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Statements to state [191]

-------------------
lalr_state [49]: {
  [Var ::= IDENT (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON DOUBLE_COLON COMMA DOT }]
}

-------------------
lalr_state [50]: {
  [Statement ::= FOR (*) LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on LPAREN to state [178]

-------------------
lalr_state [51]: {
  [DesignatorStatementOptions ::= (*) AssignOp Expr , {RPAREN SEMICOLON COMMA }]
  [DesignatorStatementOptions ::= (*) INC , {RPAREN SEMICOLON COMMA }]
  [AssignOp ::= (*) EQUAL , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [DesignatorStatementOptions ::= (*) error , {RPAREN SEMICOLON COMMA }]
  [DesignatorStatementOptions ::= (*) LPAREN ActParsOptional RPAREN , {RPAREN SEMICOLON COMMA }]
  [DesignatorStatement ::= Designator (*) DesignatorStatementOptions , {RPAREN SEMICOLON COMMA }]
  [DesignatorStatementOptions ::= (*) DEC , {RPAREN SEMICOLON COMMA }]
}
transition on LPAREN to state [174]
transition on DEC to state [173]
transition on INC to state [172]
transition on EQUAL to state [171]
transition on DesignatorStatementOptions to state [170]
transition on AssignOp to state [169]
transition on error to state [168]

-------------------
------- ast extension v0.8 summary -------
  Generated 48 base classes
  Generated 113 derived classes
  Generated 15 record classes
  Generated interface SyntaxNode
  Generated interface Visitor
  Generated adapter class VisitorAdaptor
-----------------------------------------------
lalr_state [52]: {
  [Statement ::= IF (*) LPAREN Condition RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on LPAREN to state [144]

-------------------
lalr_state [53]: {
  [Statements ::= Statements Statement (*) , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [54]: {
  [Statement ::= DesignatorStatement (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [143]

-------------------
lalr_state [55]: {
  [Statement ::= PRINT (*) LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on LPAREN to state [136]

-------------------
lalr_state [56]: {
  [Var ::= (*) IDENT , {LBRACK DOUBLE_COLON COMMA DOT }]
  [DesignatorList ::= (*) DesignatorList COMMA Designator COMMA , {MUL COMMA }]
  [DesignatorListOptional ::= (*) DesignatorList , {MUL }]
  [Designator ::= (*) Var Members , {COMMA }]
  [DesignatorStatement ::= LBRACK (*) DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {RPAREN SEMICOLON COMMA }]
  [DesignatorList ::= (*) Designator COMMA , {MUL COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LBRACK DOUBLE_COLON COMMA DOT }]
  [DesignatorListOptional ::= (*) , {MUL }]
}
transition on Var to state [61]
transition on IDENT to state [49]
transition on DesignatorList to state [126]
transition on Designator to state [125]
transition on DesignatorListOptional to state [124]

-------------------
lalr_state [57]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {SEMICOLON }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [Statement ::= RETURN (*) ExprOptional SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ExprOptional ::= (*) , {SEMICOLON }]
  [ExprOptional ::= (*) Expr , {SEMICOLON }]
}
transition on ExprOptional to state [122]
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [121]

-------------------
lalr_state [58]: {
  [Statement ::= CONTINUE (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [120]

-------------------
lalr_state [59]: {
  [MethodDeclaration ::= MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE Statements RBRACE (*) , {VOID RBRACE IDENT }]
}

-------------------
lalr_state [60]: {
  [Statement ::= BREAK (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [119]

-------------------
lalr_state [61]: {
  [Member ::= (*) LBRACK Expr RBRACK , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [MemberList ::= (*) MemberList Member , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [Designator ::= Var (*) Members , {error LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA }]
  [Member ::= (*) DOT IDENT , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [Members ::= (*) , {error LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA }]
  [Var ::= Var (*) DOUBLE_COLON IDENT , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON DOUBLE_COLON COMMA DOT }]
  [MemberList ::= (*) Member , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [Members ::= (*) MemberList , {error LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA }]
}
transition on DOT to state [67]
transition on DOUBLE_COLON to state [66]
transition on Member to state [65]
transition on LBRACK to state [64]
transition on MemberList to state [63]
transition on Members to state [62]

-------------------
lalr_state [62]: {
  [Designator ::= Var Members (*) , {error LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA }]
}

-------------------
lalr_state [63]: {
  [Member ::= (*) LBRACK Expr RBRACK , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [MemberList ::= MemberList (*) Member , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [Member ::= (*) DOT IDENT , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [Members ::= MemberList (*) , {error LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA }]
}
transition on DOT to state [67]
transition on Member to state [118]
transition on LBRACK to state [64]

-------------------
lalr_state [64]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RBRACK }]
  [Member ::= LBRACK (*) Expr RBRACK , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [70]

-------------------
lalr_state [65]: {
  [MemberList ::= Member (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}

-------------------
lalr_state [66]: {
  [Var ::= Var DOUBLE_COLON (*) IDENT , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON DOUBLE_COLON COMMA DOT }]
}
transition on IDENT to state [69]

-------------------
lalr_state [67]: {
  [Member ::= DOT (*) IDENT , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}
transition on IDENT to state [68]

-------------------
lalr_state [68]: {
  [Member ::= DOT IDENT (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}

-------------------
lalr_state [69]: {
  [Var ::= Var DOUBLE_COLON IDENT (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON DOUBLE_COLON COMMA DOT }]
}

-------------------
lalr_state [70]: {
  [Member ::= LBRACK Expr (*) RBRACK , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}
transition on RBRACK to state [117]

-------------------
lalr_state [71]: {
  [MinusOptional ::= MINUS (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [72]: {
  [ConstValue ::= (*) CHAR , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Designator ::= (*) Var Members , {LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Expr ::= MinusOptional (*) Term AddTerms , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
  [ConstValue ::= (*) BOOL , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) ConstValue , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ConstValue ::= (*) INT , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) NEW Type FactorNew , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) Designator ActParsOptionalBrackets , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
  [Term ::= (*) Factor MulFactors , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on CHAR to state [81]
transition on Var to state [61]
transition on LPAREN to state [80]
transition on Factor to state [79]
transition on Term to state [78]
transition on ConstValue to state [77]
transition on Designator to state [76]
transition on BOOL to state [75]
transition on NEW to state [74]
transition on IDENT to state [49]
transition on INT to state [73]

-------------------
lalr_state [73]: {
  [ConstValue ::= INT (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [74]: {
  [Factor ::= NEW (*) Type FactorNew , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {LPAREN LBRACK }]
  [Type ::= (*) IDENT , {LPAREN LBRACK }]
}
transition on IDENT to state [15]
transition on Type to state [109]

-------------------
lalr_state [75]: {
  [ConstValue ::= BOOL (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [76]: {
  [ActParsOptionalBrackets ::= (*) LPAREN ActParsOptional RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= Designator (*) ActParsOptionalBrackets , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ActParsOptionalBrackets ::= (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on LPAREN to state [102]
transition on ActParsOptionalBrackets to state [101]

-------------------
lalr_state [77]: {
  [Factor ::= ConstValue (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [78]: {
  [AddTermsList ::= (*) AddTerm , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddTerms ::= (*) AddTermsList , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddOp ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [AddTermsList ::= (*) AddTermsList AddTerm , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddOp ::= (*) PLUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [AddTerm ::= (*) AddOp Term , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Expr ::= MinusOptional Term (*) AddTerms , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddTerms ::= (*) , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on AddTermsList to state [98]
transition on AddOp to state [97]
transition on AddTerms to state [96]
transition on MINUS to state [95]
transition on AddTerm to state [94]
transition on PLUS to state [93]

-------------------
lalr_state [79]: {
  [MulFactorsList ::= (*) MulFactorsList MulFactor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulOp ::= (*) MUL , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MulFactor ::= (*) MulOp Factor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulFactors ::= (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulOp ::= (*) MOD , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MulFactorsList ::= (*) MulFactor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulFactors ::= (*) MulFactorsList , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulOp ::= (*) DIV , {NEW LPAREN INT BOOL CHAR IDENT }]
  [Term ::= Factor (*) MulFactors , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on MulOp to state [90]
transition on DIV to state [89]
transition on MulFactorsList to state [88]
transition on MUL to state [87]
transition on MulFactors to state [86]
transition on MOD to state [85]
transition on MulFactor to state [84]

-------------------
lalr_state [80]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [Factor ::= LPAREN (*) Expr RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [82]

-------------------
lalr_state [81]: {
  [ConstValue ::= CHAR (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [82]: {
  [Factor ::= LPAREN Expr (*) RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on RPAREN to state [83]

-------------------
lalr_state [83]: {
  [Factor ::= LPAREN Expr RPAREN (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [84]: {
  [MulFactorsList ::= MulFactor (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [85]: {
  [MulOp ::= MOD (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [86]: {
  [Term ::= Factor MulFactors (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [87]: {
  [MulOp ::= MUL (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [88]: {
  [MulOp ::= (*) MUL , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MulFactors ::= MulFactorsList (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulOp ::= (*) MOD , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MulFactorsList ::= MulFactorsList (*) MulFactor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [MulOp ::= (*) DIV , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MulFactor ::= (*) MulOp Factor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on MulOp to state [90]
transition on DIV to state [89]
transition on MUL to state [87]
transition on MOD to state [85]
transition on MulFactor to state [92]

-------------------
lalr_state [89]: {
  [MulOp ::= DIV (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [90]: {
  [ConstValue ::= (*) CHAR , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Designator ::= (*) Var Members , {LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
  [MulFactor ::= MulOp (*) Factor , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ConstValue ::= (*) BOOL , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) ConstValue , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ConstValue ::= (*) INT , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) NEW Type FactorNew , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) Designator ActParsOptionalBrackets , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
}
transition on CHAR to state [81]
transition on Var to state [61]
transition on LPAREN to state [80]
transition on Factor to state [91]
transition on ConstValue to state [77]
transition on Designator to state [76]
transition on BOOL to state [75]
transition on NEW to state [74]
transition on IDENT to state [49]
transition on INT to state [73]

-------------------
lalr_state [91]: {
  [MulFactor ::= MulOp Factor (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [92]: {
  [MulFactorsList ::= MulFactorsList MulFactor (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [93]: {
  [AddOp ::= PLUS (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [94]: {
  [AddTermsList ::= AddTerm (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [95]: {
  [AddOp ::= MINUS (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [96]: {
  [Expr ::= MinusOptional Term AddTerms (*) , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [97]: {
  [ConstValue ::= (*) CHAR , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Designator ::= (*) Var Members , {LPAREN RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddTerm ::= AddOp (*) Term , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) LPAREN Expr RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
  [ConstValue ::= (*) BOOL , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) ConstValue , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ConstValue ::= (*) INT , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) NEW Type FactorNew , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= (*) Designator ActParsOptionalBrackets , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON DOUBLE_COLON COMMA DOT }]
  [Term ::= (*) Factor MulFactors , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on CHAR to state [81]
transition on Var to state [61]
transition on LPAREN to state [80]
transition on Factor to state [79]
transition on Term to state [100]
transition on ConstValue to state [77]
transition on Designator to state [76]
transition on BOOL to state [75]
transition on NEW to state [74]
transition on IDENT to state [49]
transition on INT to state [73]

-------------------
lalr_state [98]: {
  [AddTerms ::= AddTermsList (*) , {RPAREN RBRACK DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddOp ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [AddTermsList ::= AddTermsList (*) AddTerm , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [AddOp ::= (*) PLUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [AddTerm ::= (*) AddOp Term , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on AddOp to state [97]
transition on MINUS to state [95]
transition on AddTerm to state [99]
transition on PLUS to state [93]

-------------------
lalr_state [99]: {
  [AddTermsList ::= AddTermsList AddTerm (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [100]: {
  [AddTerm ::= AddOp Term (*) , {RPAREN RBRACK PLUS MINUS DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [101]: {
  [Factor ::= Designator ActParsOptionalBrackets (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [102]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) , {RPAREN }]
  [ActParsOptionalBrackets ::= LPAREN (*) ActParsOptional RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ActPars ::= (*) ActPars COMMA Expr , {RPAREN COMMA }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) ActPars , {RPAREN }]
  [ActPars ::= (*) Expr , {RPAREN COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on ActParsOptional to state [105]
transition on Expr to state [104]
transition on ActPars to state [103]

-------------------
lalr_state [103]: {
  [ActPars ::= ActPars (*) COMMA Expr , {RPAREN COMMA }]
  [ActParsOptional ::= ActPars (*) , {RPAREN }]
}
transition on COMMA to state [107]

-------------------
lalr_state [104]: {
  [ActPars ::= Expr (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [105]: {
  [ActParsOptionalBrackets ::= LPAREN ActParsOptional (*) RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on RPAREN to state [106]

-------------------
lalr_state [106]: {
  [ActParsOptionalBrackets ::= LPAREN ActParsOptional RPAREN (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [107]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActPars ::= ActPars COMMA (*) Expr , {RPAREN COMMA }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [108]

-------------------
lalr_state [108]: {
  [ActPars ::= ActPars COMMA Expr (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [109]: {
  [FactorNew ::= (*) LBRACK Expr RBRACK , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [Factor ::= NEW Type (*) FactorNew , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [FactorNew ::= (*) LPAREN ActParsOptional RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on LPAREN to state [112]
transition on LBRACK to state [111]
transition on FactorNew to state [110]

-------------------
lalr_state [110]: {
  [Factor ::= NEW Type FactorNew (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [111]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RBRACK }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [FactorNew ::= LBRACK (*) Expr RBRACK , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [115]

-------------------
lalr_state [112]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) , {RPAREN }]
  [ActPars ::= (*) ActPars COMMA Expr , {RPAREN COMMA }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) ActPars , {RPAREN }]
  [FactorNew ::= LPAREN (*) ActParsOptional RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
  [ActPars ::= (*) Expr , {RPAREN COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on ActParsOptional to state [113]
transition on Expr to state [104]
transition on ActPars to state [103]

-------------------
lalr_state [113]: {
  [FactorNew ::= LPAREN ActParsOptional (*) RPAREN , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on RPAREN to state [114]

-------------------
lalr_state [114]: {
  [FactorNew ::= LPAREN ActParsOptional RPAREN (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [115]: {
  [FactorNew ::= LBRACK Expr (*) RBRACK , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}
transition on RBRACK to state [116]

-------------------
lalr_state [116]: {
  [FactorNew ::= LBRACK Expr RBRACK (*) , {RPAREN RBRACK PLUS MINUS MUL DIV MOD DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR SEMICOLON COMMA }]
}

-------------------
lalr_state [117]: {
  [Member ::= LBRACK Expr RBRACK (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}

-------------------
lalr_state [118]: {
  [MemberList ::= MemberList Member (*) , {error LPAREN RPAREN LBRACK RBRACK PLUS MINUS MUL DIV MOD EQUAL DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR INC DEC SEMICOLON COMMA DOT }]
}

-------------------
lalr_state [119]: {
  [Statement ::= BREAK SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [120]: {
  [Statement ::= CONTINUE SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [121]: {
  [ExprOptional ::= Expr (*) , {SEMICOLON }]
}

-------------------
lalr_state [122]: {
  [Statement ::= RETURN ExprOptional (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [123]

-------------------
lalr_state [123]: {
  [Statement ::= RETURN ExprOptional SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [124]: {
  [DesignatorStatement ::= LBRACK DesignatorListOptional (*) MUL Designator RBRACK EQUAL Designator , {RPAREN SEMICOLON COMMA }]
}
transition on MUL to state [131]

-------------------
lalr_state [125]: {
  [DesignatorList ::= Designator (*) COMMA , {MUL COMMA }]
}
transition on COMMA to state [130]

-------------------
lalr_state [126]: {
  [DesignatorList ::= DesignatorList (*) COMMA Designator COMMA , {MUL COMMA }]
  [DesignatorListOptional ::= DesignatorList (*) , {MUL }]
}
transition on COMMA to state [127]

-------------------
lalr_state [127]: {
  [Var ::= (*) IDENT , {LBRACK DOUBLE_COLON COMMA DOT }]
  [Designator ::= (*) Var Members , {COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LBRACK DOUBLE_COLON COMMA DOT }]
  [DesignatorList ::= DesignatorList COMMA (*) Designator COMMA , {MUL COMMA }]
}
transition on Var to state [61]
transition on IDENT to state [49]
transition on Designator to state [128]

-------------------
lalr_state [128]: {
  [DesignatorList ::= DesignatorList COMMA Designator (*) COMMA , {MUL COMMA }]
}
transition on COMMA to state [129]

-------------------
lalr_state [129]: {
  [DesignatorList ::= DesignatorList COMMA Designator COMMA (*) , {MUL COMMA }]
}

-------------------
lalr_state [130]: {
  [DesignatorList ::= Designator COMMA (*) , {MUL COMMA }]
}

-------------------
lalr_state [131]: {
  [Var ::= (*) IDENT , {LBRACK RBRACK DOUBLE_COLON DOT }]
  [DesignatorStatement ::= LBRACK DesignatorListOptional MUL (*) Designator RBRACK EQUAL Designator , {RPAREN SEMICOLON COMMA }]
  [Designator ::= (*) Var Members , {RBRACK }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {LBRACK RBRACK DOUBLE_COLON DOT }]
}
transition on Var to state [61]
transition on IDENT to state [49]
transition on Designator to state [132]

-------------------
lalr_state [132]: {
  [DesignatorStatement ::= LBRACK DesignatorListOptional MUL Designator (*) RBRACK EQUAL Designator , {RPAREN SEMICOLON COMMA }]
}
transition on RBRACK to state [133]

-------------------
lalr_state [133]: {
  [DesignatorStatement ::= LBRACK DesignatorListOptional MUL Designator RBRACK (*) EQUAL Designator , {RPAREN SEMICOLON COMMA }]
}
transition on EQUAL to state [134]

-------------------
lalr_state [134]: {
  [Var ::= (*) IDENT , {RPAREN LBRACK SEMICOLON DOUBLE_COLON COMMA DOT }]
  [Designator ::= (*) Var Members , {RPAREN SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {RPAREN LBRACK SEMICOLON DOUBLE_COLON COMMA DOT }]
  [DesignatorStatement ::= LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL (*) Designator , {RPAREN SEMICOLON COMMA }]
}
transition on Var to state [61]
transition on IDENT to state [49]
transition on Designator to state [135]

-------------------
lalr_state [135]: {
  [DesignatorStatement ::= LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [136]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [Statement ::= PRINT LPAREN (*) Expr NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [137]

-------------------
lalr_state [137]: {
  [Statement ::= PRINT LPAREN Expr (*) NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [NumConstOptional ::= (*) COMMA INT , {RPAREN }]
  [NumConstOptional ::= (*) , {RPAREN }]
}
transition on NumConstOptional to state [139]
transition on COMMA to state [138]

-------------------
lalr_state [138]: {
  [NumConstOptional ::= COMMA (*) INT , {RPAREN }]
}
transition on INT to state [142]

-------------------
lalr_state [139]: {
  [Statement ::= PRINT LPAREN Expr NumConstOptional (*) RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on RPAREN to state [140]

-------------------
lalr_state [140]: {
  [Statement ::= PRINT LPAREN Expr NumConstOptional RPAREN (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [141]

-------------------
lalr_state [141]: {
  [Statement ::= PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [142]: {
  [NumConstOptional ::= COMMA INT (*) , {RPAREN }]
}

-------------------
lalr_state [143]: {
  [Statement ::= DesignatorStatement SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [144]: {
  [CondFact ::= (*) Expr ExprRelopOptional , {RPAREN AND OR }]
  [CondTerm ::= (*) CondTerm AND CondFact , {RPAREN AND OR }]
  [Condition ::= (*) Condition OR CondTerm , {RPAREN OR }]
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR }]
  [CondTerm ::= (*) CondFact , {RPAREN AND OR }]
  [Condition ::= (*) CondTerm , {RPAREN OR }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [Condition ::= (*) error , {RPAREN OR }]
  [Statement ::= IF LPAREN (*) Condition RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
}
transition on Condition to state [149]
transition on CondFact to state [148]
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [147]
transition on error to state [146]
transition on CondTerm to state [145]

-------------------
lalr_state [145]: {
  [CondTerm ::= CondTerm (*) AND CondFact , {RPAREN AND OR }]
  [Condition ::= CondTerm (*) , {RPAREN OR }]
}
transition on AND to state [153]

-------------------
lalr_state [146]: {
  [Condition ::= error (*) , {RPAREN OR }]
}

-------------------
lalr_state [147]: {
  [CondFact ::= Expr (*) ExprRelopOptional , {RPAREN AND OR SEMICOLON }]
  [Relop ::= (*) LTE , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [Relop ::= (*) GT , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [ExprRelopOptional ::= (*) , {RPAREN AND OR SEMICOLON }]
  [Relop ::= (*) LT , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [Relop ::= (*) NOT_EQUAL , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [ExprRelopOptional ::= (*) Relop Expr , {RPAREN AND OR SEMICOLON }]
  [Relop ::= (*) GTE , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
  [Relop ::= (*) DOUBLE_EQUAL , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}
transition on ExprRelopOptional to state [166]
transition on Relop to state [165]
transition on DOUBLE_EQUAL to state [164]
transition on LTE to state [163]
transition on GT to state [162]
transition on LT to state [161]
transition on GTE to state [160]
transition on NOT_EQUAL to state [159]

-------------------
lalr_state [148]: {
  [CondTerm ::= CondFact (*) , {RPAREN AND OR }]
}

-------------------
lalr_state [149]: {
  [Condition ::= Condition (*) OR CondTerm , {RPAREN OR }]
  [Statement ::= IF LPAREN Condition (*) RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on OR to state [151]
transition on RPAREN to state [150]

-------------------
lalr_state [150]: {
  [Statement ::= (*) DesignatorStatement SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Statement ::= (*) LBRACE Statements RBRACE , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON }]
  [Statement ::= (*) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) CONTINUE SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) BREAK SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= IF LPAREN Condition RPAREN (*) Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON }]
  [Statement ::= (*) IF LPAREN Condition RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) RETURN ExprOptional SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Var to state [61]
transition on BREAK to state [60]
transition on CONTINUE to state [58]
transition on RETURN to state [57]
transition on LBRACK to state [56]
transition on PRINT to state [55]
transition on DesignatorStatement to state [54]
transition on Statement to state [155]
transition on IF to state [52]
transition on Designator to state [51]
transition on FOR to state [50]
transition on IDENT to state [49]
transition on LBRACE to state [48]
transition on READ to state [47]

-------------------
lalr_state [151]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR }]
  [CondFact ::= (*) Expr ExprRelopOptional , {RPAREN AND OR }]
  [Condition ::= Condition OR (*) CondTerm , {RPAREN OR }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [CondTerm ::= (*) CondTerm AND CondFact , {RPAREN AND OR }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [CondTerm ::= (*) CondFact , {RPAREN AND OR }]
}
transition on CondFact to state [148]
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [147]
transition on CondTerm to state [152]

-------------------
lalr_state [152]: {
  [CondTerm ::= CondTerm (*) AND CondFact , {RPAREN AND OR }]
  [Condition ::= Condition OR CondTerm (*) , {RPAREN OR }]
}
transition on AND to state [153]

-------------------
lalr_state [153]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE AND OR }]
  [CondFact ::= (*) Expr ExprRelopOptional , {RPAREN AND OR }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [CondTerm ::= CondTerm AND (*) CondFact , {RPAREN AND OR }]
}
transition on CondFact to state [154]
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [147]

-------------------
lalr_state [154]: {
  [CondTerm ::= CondTerm AND CondFact (*) , {RPAREN AND OR }]
}

-------------------
lalr_state [155]: {
  [ElseOptional ::= (*) ELSE Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [ElseOptional ::= (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= IF LPAREN Condition RPAREN Statement (*) ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on ELSE to state [157]
transition on ElseOptional to state [156]

-------------------
lalr_state [156]: {
  [Statement ::= IF LPAREN Condition RPAREN Statement ElseOptional (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [157]: {
  [Statement ::= (*) DesignatorStatement SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Statement ::= (*) LBRACE Statements RBRACE , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON }]
  [Statement ::= (*) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) CONTINUE SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) BREAK SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [ElseOptional ::= ELSE (*) Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON }]
  [Statement ::= (*) IF LPAREN Condition RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) RETURN ExprOptional SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Var to state [61]
transition on BREAK to state [60]
transition on CONTINUE to state [58]
transition on RETURN to state [57]
transition on LBRACK to state [56]
transition on PRINT to state [55]
transition on DesignatorStatement to state [54]
transition on Statement to state [158]
transition on IF to state [52]
transition on Designator to state [51]
transition on FOR to state [50]
transition on IDENT to state [49]
transition on LBRACE to state [48]
transition on READ to state [47]

-------------------
lalr_state [158]: {
  [ElseOptional ::= ELSE Statement (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [159]: {
  [Relop ::= NOT_EQUAL (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [160]: {
  [Relop ::= GTE (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [161]: {
  [Relop ::= LT (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [162]: {
  [Relop ::= GT (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [163]: {
  [Relop ::= LTE (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [164]: {
  [Relop ::= DOUBLE_EQUAL (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [165]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN AND OR SEMICOLON }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ExprRelopOptional ::= Relop (*) Expr , {RPAREN AND OR SEMICOLON }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [167]

-------------------
lalr_state [166]: {
  [CondFact ::= Expr ExprRelopOptional (*) , {RPAREN AND OR SEMICOLON }]
}

-------------------
lalr_state [167]: {
  [ExprRelopOptional ::= Relop Expr (*) , {RPAREN AND OR SEMICOLON }]
}

-------------------
lalr_state [168]: {
  [DesignatorStatementOptions ::= error (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [169]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN SEMICOLON COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [DesignatorStatementOptions ::= AssignOp (*) Expr , {RPAREN SEMICOLON COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [177]

-------------------
lalr_state [170]: {
  [DesignatorStatement ::= Designator DesignatorStatementOptions (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [171]: {
  [AssignOp ::= EQUAL (*) , {NEW LPAREN MINUS INT BOOL CHAR IDENT }]
}

-------------------
lalr_state [172]: {
  [DesignatorStatementOptions ::= INC (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [173]: {
  [DesignatorStatementOptions ::= DEC (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [174]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {RPAREN COMMA }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) , {RPAREN }]
  [ActPars ::= (*) ActPars COMMA Expr , {RPAREN COMMA }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [ActParsOptional ::= (*) ActPars , {RPAREN }]
  [DesignatorStatementOptions ::= LPAREN (*) ActParsOptional RPAREN , {RPAREN SEMICOLON COMMA }]
  [ActPars ::= (*) Expr , {RPAREN COMMA }]
}
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on ActParsOptional to state [175]
transition on Expr to state [104]
transition on ActPars to state [103]

-------------------
lalr_state [175]: {
  [DesignatorStatementOptions ::= LPAREN ActParsOptional (*) RPAREN , {RPAREN SEMICOLON COMMA }]
}
transition on RPAREN to state [176]

-------------------
lalr_state [176]: {
  [DesignatorStatementOptions ::= LPAREN ActParsOptional RPAREN (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [177]: {
  [DesignatorStatementOptions ::= AssignOp Expr (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [178]: {
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [DesignatorStatementListOptional ::= (*) , {SEMICOLON }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON COMMA }]
  [DesignatorStatementList ::= (*) DesignatorStatement , {SEMICOLON COMMA }]
  [DesignatorStatementListOptional ::= (*) DesignatorStatementList , {SEMICOLON }]
  [Statement ::= FOR LPAREN (*) DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatementList ::= (*) DesignatorStatementList COMMA DesignatorStatement , {SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON COMMA }]
}
transition on Var to state [61]
transition on DesignatorStatementList to state [181]
transition on DesignatorStatement to state [180]
transition on DesignatorStatementListOptional to state [179]
transition on IDENT to state [49]
transition on Designator to state [51]
transition on LBRACK to state [56]

-------------------
lalr_state [179]: {
  [Statement ::= FOR LPAREN DesignatorStatementListOptional (*) SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [184]

-------------------
lalr_state [180]: {
  [DesignatorStatementList ::= DesignatorStatement (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [181]: {
  [DesignatorStatementListOptional ::= DesignatorStatementList (*) , {RPAREN SEMICOLON }]
  [DesignatorStatementList ::= DesignatorStatementList (*) COMMA DesignatorStatement , {RPAREN SEMICOLON COMMA }]
}
transition on COMMA to state [182]

-------------------
lalr_state [182]: {
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {RPAREN SEMICOLON COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {RPAREN SEMICOLON COMMA }]
  [DesignatorStatementList ::= DesignatorStatementList COMMA (*) DesignatorStatement , {RPAREN SEMICOLON COMMA }]
}
transition on Var to state [61]
transition on DesignatorStatement to state [183]
transition on IDENT to state [49]
transition on Designator to state [51]
transition on LBRACK to state [56]

-------------------
lalr_state [183]: {
  [DesignatorStatementList ::= DesignatorStatementList COMMA DesignatorStatement (*) , {RPAREN SEMICOLON COMMA }]
}

-------------------
lalr_state [184]: {
  [Expr ::= (*) MinusOptional Term AddTerms , {DOUBLE_EQUAL NOT_EQUAL GT GTE LT LTE SEMICOLON }]
  [CondFact ::= (*) Expr ExprRelopOptional , {SEMICOLON }]
  [MinusOptional ::= (*) , {NEW LPAREN INT BOOL CHAR IDENT }]
  [CondFactOptional ::= (*) , {SEMICOLON }]
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON (*) CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [MinusOptional ::= (*) MINUS , {NEW LPAREN INT BOOL CHAR IDENT }]
  [CondFactOptional ::= (*) CondFact , {SEMICOLON }]
}
transition on CondFact to state [186]
transition on MinusOptional to state [72]
transition on MINUS to state [71]
transition on Expr to state [147]
transition on CondFactOptional to state [185]

-------------------
lalr_state [185]: {
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional (*) SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [187]

-------------------
lalr_state [186]: {
  [CondFactOptional ::= CondFact (*) , {SEMICOLON }]
}

-------------------
lalr_state [187]: {
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [DesignatorStatementListOptional ::= (*) , {RPAREN }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {RPAREN COMMA }]
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON (*) DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatementList ::= (*) DesignatorStatement , {RPAREN COMMA }]
  [DesignatorStatementListOptional ::= (*) DesignatorStatementList , {RPAREN }]
  [DesignatorStatementList ::= (*) DesignatorStatementList COMMA DesignatorStatement , {RPAREN COMMA }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {RPAREN COMMA }]
}
transition on Var to state [61]
transition on DesignatorStatementList to state [181]
transition on DesignatorStatementListOptional to state [188]
transition on DesignatorStatement to state [180]
transition on IDENT to state [49]
transition on Designator to state [51]
transition on LBRACK to state [56]

-------------------
lalr_state [188]: {
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional (*) RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on RPAREN to state [189]

-------------------
lalr_state [189]: {
  [Statement ::= (*) DesignatorStatement SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Statement ::= (*) LBRACE Statements RBRACE , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN (*) Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON }]
  [Statement ::= (*) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) CONTINUE SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) BREAK SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON }]
  [Statement ::= (*) IF LPAREN Condition RPAREN Statement ElseOptional , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) RETURN ExprOptional SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Var to state [61]
transition on BREAK to state [60]
transition on CONTINUE to state [58]
transition on RETURN to state [57]
transition on LBRACK to state [56]
transition on PRINT to state [55]
transition on Statement to state [190]
transition on DesignatorStatement to state [54]
transition on IF to state [52]
transition on Designator to state [51]
transition on FOR to state [50]
transition on IDENT to state [49]
transition on LBRACE to state [48]
transition on READ to state [47]

-------------------
lalr_state [190]: {
  [Statement ::= FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [191]: {
  [Statement ::= (*) DesignatorStatement SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Designator ::= (*) Var Members , {error LPAREN EQUAL INC DEC }]
  [Statement ::= LBRACE Statements (*) RBRACE , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [Statement ::= (*) LBRACE Statements RBRACE , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [DesignatorStatement ::= (*) Designator DesignatorStatementOptions , {SEMICOLON }]
  [Statement ::= (*) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) CONTINUE SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) FOR LPAREN DesignatorStatementListOptional SEMICOLON CondFactOptional SEMICOLON DesignatorStatementListOptional RPAREN Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) READ LPAREN Designator RPAREN SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statements ::= Statements (*) Statement , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) BREAK SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {error LPAREN LBRACK EQUAL INC DEC DOUBLE_COLON DOT }]
  [DesignatorStatement ::= (*) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator , {SEMICOLON }]
  [Statement ::= (*) IF LPAREN Condition RPAREN Statement ElseOptional , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Statement ::= (*) RETURN ExprOptional SEMICOLON , {BREAK IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on Var to state [61]
transition on BREAK to state [60]
transition on RBRACE to state [192]
transition on CONTINUE to state [58]
transition on RETURN to state [57]
transition on LBRACK to state [56]
transition on PRINT to state [55]
transition on DesignatorStatement to state [54]
transition on Statement to state [53]
transition on IF to state [52]
transition on Designator to state [51]
transition on FOR to state [50]
transition on IDENT to state [49]
transition on LBRACE to state [48]
transition on READ to state [47]

-------------------
lalr_state [192]: {
  [Statement ::= LBRACE Statements RBRACE (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [193]: {
  [Var ::= (*) IDENT , {RPAREN LBRACK DOUBLE_COLON DOT }]
  [Designator ::= (*) Var Members , {RPAREN }]
  [Statement ::= READ LPAREN (*) Designator RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
  [Var ::= (*) Var DOUBLE_COLON IDENT , {RPAREN LBRACK DOUBLE_COLON DOT }]
}
transition on Var to state [61]
transition on IDENT to state [49]
transition on Designator to state [194]

-------------------
lalr_state [194]: {
  [Statement ::= READ LPAREN Designator (*) RPAREN SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on RPAREN to state [195]

-------------------
lalr_state [195]: {
  [Statement ::= READ LPAREN Designator RPAREN (*) SEMICOLON , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}
transition on SEMICOLON to state [196]

-------------------
lalr_state [196]: {
  [Statement ::= READ LPAREN Designator RPAREN SEMICOLON (*) , {BREAK ELSE IF PRINT READ RETURN CONTINUE FOR LBRACE RBRACE LBRACK IDENT }]
}

-------------------
lalr_state [197]: {
  [Parameter ::= (*) Type VarListElement , {RPAREN COMMA }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [FormParsList ::= FormParsList COMMA (*) Parameter , {RPAREN COMMA }]
}
transition on Parameter to state [198]
transition on IDENT to state [15]
transition on Type to state [35]

-------------------
lalr_state [198]: {
  [FormParsList ::= FormParsList COMMA Parameter (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [199]: {
  [Parameter ::= Type VarListElement (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [200]: {
  [MethodDeclarationTypeAndName ::= Type IDENT (*) , {LPAREN }]
}

-------------------
lalr_state [201]: {
  [ConstDeclarationList ::= (*) ConstDeclarationList COMMA ConstDeclarationElement , {SEMICOLON COMMA }]
  [ConstDeclarationList ::= (*) ConstDeclarationElement , {SEMICOLON COMMA }]
  [ConstDeclaration ::= CONST Type (*) ConstDeclarationList , {SEMICOLON }]
  [ConstDeclarationElement ::= (*) IDENT EQUAL ConstValue , {SEMICOLON COMMA }]
}
transition on ConstDeclarationElement to state [204]
transition on IDENT to state [203]
transition on ConstDeclarationList to state [202]

-------------------
lalr_state [202]: {
  [ConstDeclarationList ::= ConstDeclarationList (*) COMMA ConstDeclarationElement , {SEMICOLON COMMA }]
  [ConstDeclaration ::= CONST Type ConstDeclarationList (*) , {SEMICOLON }]
}
transition on COMMA to state [207]

-------------------
lalr_state [203]: {
  [ConstDeclarationElement ::= IDENT (*) EQUAL ConstValue , {SEMICOLON COMMA }]
}
transition on EQUAL to state [205]

-------------------
lalr_state [204]: {
  [ConstDeclarationList ::= ConstDeclarationElement (*) , {SEMICOLON COMMA }]
}

-------------------
lalr_state [205]: {
  [ConstValue ::= (*) BOOL , {SEMICOLON COMMA }]
  [ConstValue ::= (*) INT , {SEMICOLON COMMA }]
  [ConstDeclarationElement ::= IDENT EQUAL (*) ConstValue , {SEMICOLON COMMA }]
  [ConstValue ::= (*) CHAR , {SEMICOLON COMMA }]
}
transition on INT to state [73]
transition on CHAR to state [81]
transition on BOOL to state [75]
transition on ConstValue to state [206]

-------------------
lalr_state [206]: {
  [ConstDeclarationElement ::= IDENT EQUAL ConstValue (*) , {SEMICOLON COMMA }]
}

-------------------
lalr_state [207]: {
  [ConstDeclarationElement ::= (*) IDENT EQUAL ConstValue , {SEMICOLON COMMA }]
  [ConstDeclarationList ::= ConstDeclarationList COMMA (*) ConstDeclarationElement , {SEMICOLON COMMA }]
}
transition on IDENT to state [203]
transition on ConstDeclarationElement to state [208]

-------------------
lalr_state [208]: {
  [ConstDeclarationList ::= ConstDeclarationList COMMA ConstDeclarationElement (*) , {SEMICOLON COMMA }]
}

-------------------
lalr_state [209]: {
  [Declaration ::= ConstDeclaration SEMICOLON (*) , {error CONST LBRACE IDENT }]
}

-------------------
lalr_state [210]: {
  [NamespaceName ::= IDENT (*) , {LBRACE }]
}

-------------------
lalr_state [211]: {
  [Namespace ::= NAMESPACE NamespaceName (*) LBRACE DeclarationList LBRACE MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
}
transition on LBRACE to state [212]

-------------------
lalr_state [212]: {
  [Namespace ::= NAMESPACE NamespaceName LBRACE (*) DeclarationList LBRACE MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
  [DeclarationList ::= (*) DeclarationList Declaration , {error CONST LBRACE IDENT }]
  [DeclarationList ::= (*) , {error CONST LBRACE IDENT }]
}
transition on DeclarationList to state [213]

-------------------
lalr_state [213]: {
  [ConstDeclaration ::= (*) CONST Type ConstDeclarationList , {SEMICOLON }]
  [Namespace ::= NAMESPACE NamespaceName LBRACE DeclarationList (*) LBRACE MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
  [DeclarationList ::= DeclarationList (*) Declaration , {error CONST LBRACE IDENT }]
  [Declaration ::= (*) VarDeclaration SEMICOLON , {error CONST LBRACE IDENT }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [VarDeclaration ::= (*) error , {SEMICOLON }]
  [Declaration ::= (*) ConstDeclaration SEMICOLON , {error CONST LBRACE IDENT }]
  [Type ::= (*) IDENT , {IDENT }]
  [VarDeclaration ::= (*) Type VarList , {SEMICOLON }]
}
transition on IDENT to state [15]
transition on VarDeclaration to state [14]
transition on error to state [13]
transition on Type to state [12]
transition on LBRACE to state [214]
transition on Declaration to state [11]
transition on CONST to state [9]
transition on ConstDeclaration to state [8]

-------------------
lalr_state [214]: {
  [MethodsDeclarationList ::= (*) MethodsDeclarationList MethodDeclaration , {VOID RBRACE IDENT }]
  [MethodsDeclarationList ::= (*) , {VOID RBRACE IDENT }]
  [Namespace ::= NAMESPACE NamespaceName LBRACE DeclarationList LBRACE (*) MethodsDeclarationList RBRACE RBRACE , {error CONST LBRACE IDENT }]
}
transition on MethodsDeclarationList to state [215]

-------------------
lalr_state [215]: {
  [MethodDeclaration ::= (*) MethodDeclarationTypeAndName LPAREN FormPars RPAREN VarDeclarationListOptional LBRACE Statements RBRACE , {VOID RBRACE IDENT }]
  [Type ::= (*) IDENT DOUBLE_COLON IDENT , {IDENT }]
  [MethodDeclarationTypeAndName ::= (*) VOID IDENT , {LPAREN }]
  [Type ::= (*) IDENT , {IDENT }]
  [Namespace ::= NAMESPACE NamespaceName LBRACE DeclarationList LBRACE MethodsDeclarationList (*) RBRACE RBRACE , {error CONST LBRACE IDENT }]
  [MethodDeclarationTypeAndName ::= (*) Type IDENT , {LPAREN }]
  [MethodsDeclarationList ::= MethodsDeclarationList (*) MethodDeclaration , {VOID RBRACE IDENT }]
}
transition on VOID to state [32]
transition on MethodDeclarationTypeAndName to state [31]
transition on IDENT to state [15]
transition on RBRACE to state [216]
transition on MethodDeclaration to state [29]
transition on Type to state [28]

-------------------
lalr_state [216]: {
  [Namespace ::= NAMESPACE NamespaceName LBRACE DeclarationList LBRACE MethodsDeclarationList RBRACE (*) RBRACE , {error CONST LBRACE IDENT }]
}
transition on RBRACE to state [217]

-------------------
lalr_state [217]: {
  [Namespace ::= NAMESPACE NamespaceName LBRACE DeclarationList LBRACE MethodsDeclarationList RBRACE RBRACE (*) , {error CONST LBRACE IDENT }]
}

-------------------
lalr_state [218]: {
  [$START ::= Program EOF (*) , {EOF }]
}

-------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  0 errors and 6 warnings
  49 terminals, 64 non-terminals, and 129 productions declared, 
  producing 219 unique parse states.
  5 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (0 expected).
  Code written to "MJParser.java", and "sym.java".
---------------------------------------------------- (v0.10k)
