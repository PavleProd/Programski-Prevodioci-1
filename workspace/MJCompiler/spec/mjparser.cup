package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID;
terminal EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;

terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUAL, DOUBLE_EQUAL, NOT_EQUAL;
terminal GT, GTE, LT, LTE, AND, OR;
terminal INC, DEC;
terminal SEMICOLON, COLON, COMMA, DOT;

terminal Integer INT;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

terminal TYPE_INT, TYPE_BOOL, TYPE_CHAR;

nonterminal Program, ProgramDeclList, ProgramDecl, ConstDeclList;

nonterminal Type, BasicType, Value, BasicValue;
nonterminal BasicDeclaration, BasicDefinition, BasicDefinitionNoType, BasicDefinitionList, BasicDefinitionListNoType;
nonterminal Declaration, Definition;

/* PROGRAM */

Program ::= (Program) PROGRAM IDENT:programName ProgramDeclList LBRACE RBRACE
;


/* TIPOVI, Basic koristiti samo kad nam on specificno treba */

Type ::= (Type_Custom) IDENT:typeName
		 |
		 (Type_Basic) BasicType
		 ;
		 
BasicType ::= (BasicType_Int) TYPE_INT
			  |
			  (BasicType_Bool) TYPE_BOOL
			  |
			  (BasicType_Char) TYPE_CHAR
			  ;

Value ::= (Value_Custom) IDENT:value
		  |
		  (Value_Basic) BasicValue
		  ;

BasicValue ::= (BasicValue_Int) INT
			   |
			   (BasicValue_Bool) BOOL
			   |
			   (BasicValue_Char) CHAR
			   ;

/* DEKLARACIJA I DEFINICIJA promenljivih, namerno bez ; jer moze da bude vise u istom redu */
			   
Declaration ::= (Declaration_Custom) Type IDENT:varName
				|
				(Declaration_Basic) BasicDeclaration;
				
BasicDeclaration ::= (BasicDeclaration) BasicType IDENT:varName
					 ;

Definition ::= (Definition_Custom) Type IDENT:varName EQUAL Value
			   |
			   (Definition_Basic) BasicDefinition
			   ;
			   
BasicDefinitionList ::= (BasicDefinitionList) BasicType BasicDefinitionListNoType
						;

BasicDefinitionListNoType ::= (BasicDefinitionListNoType_One) BasicDefinitionNoType
							  |
							  (BasicDefinitionListNoType_Multiple) BasicDefinitionListNoType COMMA BasicDefinitionNoType
							  ;

BasicDefinitionNoType ::= (BasicDefinitionNoType) IDENT:varName EQUAL BasicValue
						  ;
			   
BasicDefinition ::= (BasicDefinition ) BasicType IDENT:varName EQUAL BasicValue
					;
			   
/* PROGRAM DEFINICIJA */

ProgramDeclList ::= (ProgramDeclList_Exists) ProgramDeclList ProgramDecl
					|
					(ProgramDeclList_Epsilon) /* epsilon */
					;

ProgramDecl ::= (ProgramDecl) ConstDeclList SEMICOLON
				;

ConstDeclList ::= (ConstDeclList) CONST BasicDefinitionList
				  ;
				  



			  

			  
			  

















