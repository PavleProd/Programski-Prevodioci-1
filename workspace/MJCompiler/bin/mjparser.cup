package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID;
terminal EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;

terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUAL, DOUBLE_EQUAL, NOT_EQUAL;
terminal GT, GTE, LT, LTE, AND, OR;
terminal INC, DEC;
terminal SEMICOLON, COLON, DOUBLE_COLON, COMMA, DOT;

terminal Integer INT;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program, Type;
nonterminal Namespace, Declaration, DeclarationList;
nonterminal ConstDeclaration, ConstDeclarationList, ConstDeclarationElement, ConstValue;
nonterminal VarDeclarationOptional, VarDeclaration, VarList, VarListElement, VarOrArray;
nonterminal MethodDeclaration, MethodDeclarationType, FormPars, FormParsList, Parameter, Statement, Statements;

nonterminal ExprOptional, Expr, ExprRelopOptional, ActPars, ActParsOptionalBrackets, ActParsOptional;
nonterminal Term, AddTerms, AddTermsList, AddTerm;
nonterminal Factor, MulFactors, MulFactorsList, MulFactor;
nonterminal MinusOptional, Label, AssignOp, Relop, AddOp, MulOp;
nonterminal DesignatorStatement, DesignatorStatementOptions, DesignatorListOptional, DesignatorList, DesignatorList2;
nonterminal Designator, Members, MemberList, Member, ArrayOrVarMember;

nonterminal ElseOptional, NumConstOptional;
nonterminal Condition, CondTerm, CondFact, CondFactOptional;

precedence left ELSE;

/* PROGRAM */

Program ::= (Program) PROGRAM IDENT:programName Namespace DeclarationList LBRACE MethodDeclaration RBRACE
			;
			
Type ::= (Type_NoScope) IDENT:typeName
		 |
		 (Type_Scope) Type DOUBLE_COLON IDENT:typeName
		 ;

Namespace ::= (Namespace_Define) NAMESPACE IDENT:namespaceName LBRACE DeclarationList LBRACE MethodDeclaration RBRACE RBRACE
			  |
			  (Namespace_Skip) /* EPSILON */
			  ;

DeclarationList ::= (DeclarationList_Define) DeclarationList Declaration
					|
					(DeclarationList_SKIP) /* EPSILON */
					;

Declaration ::= (Declaration_Const) ConstDeclaration SEMICOLON
				|
				(Declaration_Var) VarDeclaration SEMICOLON
				;

/* CONST DECLARATION */

ConstDeclaration ::= (ConstDeclaration) CONST Type ConstDeclarationList
					 ;
		 
ConstDeclarationList ::= (ConstDeclarationList_One)  ConstDeclarationElement
						 |
						 (ConstDeclarationList_Multiple) ConstDeclarationList COMMA ConstDeclarationElement
						 ;

ConstDeclarationElement ::= (ConstDeclarationElement) IDENT:varName EQUAL ConstValue
							;
						
ConstValue ::= (ConstValue_INT) INT
			   |
			   (ConstValue_BOOL) BOOL
			   |
			   (ConstValue_CHAR) CHAR
			   ;

/* VAR DECLARATION */
VarDeclarationOptional ::= (VarDeclarationOptional_Declare) VarDeclaration
						   |
						   (VarDeclarationOptional_SKIP) /* EPSILON */
						   ;

VarDeclaration ::= (VarDeclaration) Type VarList
				   ;

VarList ::= (VarList_One) VarListElement
			|
			(VarList_Multiple) VarList COMMA VarListElement
			;
			
VarListElement ::= (VarListElement) IDENT:elementName VarOrArray
				   ;
				  
VarOrArray ::= (VarOrArray_Array) LBRACK RBRACK
			   |
			   (VarOrArray_Var) /* EPSILON */
			   ;
	
/* METODE */	
		   
MethodDeclaration ::= (MethodDeclaration_Declare) MethodDeclarationType IDENT:methodName LPAREN FormPars RPAREN VarDeclarationOptional LBRACE Statements RBRACE
					  |
					  (MethodDeclaration_Skip) /* EPSILON */
					  ;
					  
MethodDeclarationType ::= (MethodDeclarationType_Type) Type
						  |
						  (MethodDeclarationType_Void) VOID
						  ;

FormPars ::= (FormPars_OneOrMore) FormParsList
			 |
			 (FormPars_None) /* EPSILON */
			 ;
			 
FormParsList ::= (FormParsList_Multiple) FormParsList COMMA Parameter
				 |
				 (FormParsList_One) Parameter
				 ;
			 
Parameter ::= (Parameter) Type VarListElement
			  ;
			  
Statements ::= (Statements_OneOrMore) Statements Statement
			   |
			   (Statements_None) /* EPSILON */
			   ;
			 
Statement ::= (Statement_DesignatorStatement) DesignatorStatement SEMICOLON
			  |
			  (Statement_Break) BREAK SEMICOLON
			  |
			  (Statement_Continue) CONTINUE SEMICOLON
			  |
			  (Statement_Return) RETURN ExprOptional SEMICOLON
			  |
			  (Statement_Read) READ LPAREN Designator RPAREN SEMICOLON
			  |
			  (Statement_Print) PRINT LPAREN Expr NumConstOptional RPAREN SEMICOLON
			  |
			  (Statement_If) IF LPAREN Condition RPAREN Statement ElseOptional
			  |
			  (Statement_For) FOR LPAREN DesignatorList2 SEMICOLON CondFactOptional SEMICOLON DesignatorList2 RPAREN Statement
			  |
			  (Statement_Statements) LBRACE Statements RBRACE
			  ;
			  
ElseOptional ::= (ElseOptional_Define) ELSE Statement
				 |
				 (ElseOptional_Skip) /* EPSILON */
				 ;
			  
NumConstOptional ::= (NumConstOptional_Define) COMMA INT
				     |
				     (NumConstOptional_Skip) /* EPSILON */
				     ;
		     
/* CONDITION */

Condition ::= (Condition_One) CondTerm
			  |
			  (Condition_MultipleOR) Condition OR CondTerm
			  ;
				
CondTerm ::= (CondTerm_One) CondFact
			 |
			 (CondTerm_MultipleAND) CondTerm AND CondFact
			 ;

CondFactOptional ::= (CondFact_Define) CondFact
					 |
					 (CondFact_Skip) /* EPSILON */
					 ;

CondFact ::= (CondFact) Expr ExprRelopOptional
			 ;

/* EXPR */

ExprRelopOptional ::= (ExprRelopOptional_Define) Relop Expr
					  |
					  (ExprRelopOptional_Skip) /* EPSILON */;

ExprOptional ::= (ExprOptional_Define) Expr
				 |
				 (ExprOptional_Skip) /* EPSILON */
				 ;
				 
ActParsOptionalBrackets ::= (ActParsOptionalBrackets_Define) LPAREN ActPars RPAREN
							|
							(ActParsOptionalBrackets_Skip) /* EPSILON */
							;

ActParsOptional ::= (ActParsOptional_Define) ActPars
					|
					(ActParsOptional_Skip) /* EPSILON */
					;
		
ActPars ::= (ActPars_One) Expr
			|
			(ActPars_Multiple) ActPars COMMA Expr
			;
		  
Expr ::= (Expr) MinusOptional Term AddTerms
		 ;

/* TERM */

Term ::= (Term) Factor MulFactors
		 ;
		
AddTerms ::= (AddTerms_Define) AddTermsList
			 |
			 (AddTerms_Skip) /* Epsilon */
			 ;

AddTermsList ::= (AddTermsList_Multiple) AddTermsList AddTerm
				 |
				 (AddTermsList_One) AddTerm
				 ;
				 
AddTerm ::= (AddTerm) AddOp Term
			;

/* FACTOR */

Factor ::= (Factor_Designator) Designator ActParsOptionalBrackets
		   |
		   (Factor_Const) ConstValue /* int, bool, char konstanta */
		   |
		   (Factor_Expr) LPAREN Expr RPAREN
		   ;
	
MulFactors ::= (MulFactors_Define) MulFactorsList
			   |
			   (MulFactors_Skip) /* Epsilon */
			   ;

MulFactorsList ::= (MulFactorsList_Multiple) MulFactorsList MulFactor
				   |
				   (MulFactorsList_Skip) MulFactor
				   ;
				 
MulFactor ::= (MulFactor) MulOp Factor
			  ;

MinusOptional ::= (MinusOptional_Define) MINUS
			      |
			      (MinusOptional_Skip) /* EPSILON */
			      ;

/* DESIGNATOR */

DesignatorStatement ::= (DesignatorStatement) Designator DesignatorStatementOptions
					;
					
DesignatorStatementOptions ::= (DesignatorStatementOptions_AssignOpExpr) AssignOp Expr
							   |
							   (DesignatorStatementOptions_ActPars) LPAREN ActParsOptional RPAREN
							   |
							   (DesignatorStatementOptions_Inc) INC
							   |
							   (DesignatorStatementOptions_Dec) DEC
							   |
							   (DesignatorStatementOptions_DesignatorList) LBRACK DesignatorListOptional MUL Designator RBRACK EQUAL Designator
							   ;
							   
DesignatorListOptional ::= (DesignatorListOptional_Define) DesignatorList
						   |
						   (DesignatorListOptional_Skip) /* EPSILON */
						   ;
						
DesignatorList ::= (DesignatorList_One) Designator COMMA
				   |
				   (DesignatorList_Multiple) DesignatorList COMMA Designator COMMA
				   ; 

DesignatorList2 ::= (DesignatorList2_One) Designator
					|
					(DesignatorList2_Multiple) DesignatorList2 COMMA Designator
					;

Designator ::= (Designator) Type Members
			   ;
			   
Members ::= (Members_Define) MemberList
			|
			(Members_Skip) /* EPSILON */
			;
			  
MemberList ::= (MemberList_Multiple) MemberList Member
			   |
			   (MemberList_One) Member
			   ;

Member ::= (Member) DOT ArrayOrVarMember
		   ;
		   
ArrayOrVarMember ::= (ArrayOrVarMember_Var) IDENT:varValue
					 |
					 (ArrayOrVarMember_Array) LBRACK Expr RBRACK
					 ;

Label ::= (Label) IDENT:label
		 ;

AssignOp ::= (AssignOp_EQUAL) EQUAL;

Relop ::= (Relop_Double_Equal) DOUBLE_EQUAL
		  |
		  (Relop_Not_Equal) NOT_EQUAL
		  |
		  (Relop_GT) GT
		  |
		  (Relop_GTE) GTE
		  |
		  (Relop_LT) LT
		  |
		  (Relop_LTE) LTE
		  ;

AddOp ::= (AddOp_Plus) PLUS
		  |
		  (AddOp_Minus) MINUS
		  ;
			 
MulOp ::= (MulOp_Mul) MUL
		  |
		  (MulOp_Div) DIV
		  |
		  (MulOp_Mod) MOD
		  ;
			  


















