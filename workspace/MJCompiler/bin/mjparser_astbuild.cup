package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID;
terminal EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;

terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUAL, DOUBLE_EQUAL, NOT_EQUAL;
terminal GT, GTE, LT, LTE, AND, OR;
terminal INC, DEC;
terminal SEMICOLON, COLON, DOUBLE_COLON, COMMA, DOT;

terminal Integer INT;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Namespace Namespace;
nonterminal Declaration Declaration;
nonterminal DeclarationList DeclarationList;
nonterminal ConstDeclaration ConstDeclaration;
nonterminal ConstDeclarationList ConstDeclarationList;
nonterminal VarDeclarationListOptional VarDeclarationListOptional;
nonterminal VarDeclaration VarDeclaration;
nonterminal VarList VarList;
nonterminal VarOrArray VarOrArray;
nonterminal MethodsDeclarationList MethodsDeclarationList;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal Statement Statement;
nonterminal Statements Statements;

nonterminal ExprRelopOptional ExprRelopOptional;
nonterminal ActPars ActPars;
nonterminal ActParsOptionalBrackets ActParsOptionalBrackets;
nonterminal ActParsOptional ActParsOptional;
nonterminal FactorNew FactorNew;
nonterminal MinusOptional MinusOptional;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal Relop Relop;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorStatementOptions DesignatorStatementOptions;
nonterminal DesignatorListOptional DesignatorListOptional;
nonterminal DesignatorList DesignatorList;
nonterminal DesignatorStatementListOptional DesignatorStatementListOptional;
nonterminal DesignatorStatementList DesignatorStatementList;
nonterminal Members Members;
nonterminal MemberList MemberList;
nonterminal Member Member;
nonterminal ArrayOrVarMember ArrayOrVarMember;

nonterminal ElseOptional ElseOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal CondFactOptional CondFactOptional;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, MethodDeclaration, MethodDeclarationTypeAndName, NamespaceName;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstDeclarationElement, VarListElement, Parameter;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Var, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstValue, Type;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ExprOptional, Expr, Term, Factor;

precedence left ELSE;

/* PROGRAM */

Program ::= (Program) PROGRAM ProgramName:P1 Namespace:N2 DeclarationList:D3 LBRACE MethodsDeclarationList:M4 RBRACE {: RESULT=new Program(P1, N2, D3, M4); RESULT.setLine(P1left); :}
			;

ProgramName ::= (ProgramName) IDENT:name {: RESULT=new ProgramName(name); RESULT.setLine(nameleft); :}
				;
			
Type ::= (Type_NoScope) IDENT:typeName {: RESULT=new Type_NoScope(typeName); RESULT.setLine(typeNameleft); :}
		 |
		 (Type_Scope) IDENT:namespaceName DOUBLE_COLON IDENT:typeName {: RESULT=new Type_Scope(namespaceName, typeName); RESULT.setLine(namespaceNameleft); :}
		 ;
		 
Var ::=  (Var_NoScope) IDENT:varName {: RESULT=new Var_NoScope(varName); RESULT.setLine(varNameleft); :}
		 |
		 (Var_Scope) IDENT:namespaceName DOUBLE_COLON IDENT:varName {: RESULT=new Var_Scope(namespaceName, varName); RESULT.setLine(namespaceNameleft); :}
		 ;

Namespace ::= (Namespace_Define) NAMESPACE NamespaceName:N1 LBRACE DeclarationList:D2 LBRACE MethodsDeclarationList:M3 RBRACE RBRACE {: RESULT=new Namespace_Define(N1, D2, M3); RESULT.setLine(N1left); :}
			  |
			  (Namespace_Skip) {: RESULT=new Namespace_Skip(); :} /* EPSILON */
			  ;
			  
NamespaceName ::= (NamespaceName) IDENT:namespaceName {: RESULT=new NamespaceName(namespaceName); RESULT.setLine(namespaceNameleft); :}
				  ;

DeclarationList ::= (DeclarationList_Define) DeclarationList:D1 Declaration:D2 {: RESULT=new DeclarationList_Define(D1, D2); RESULT.setLine(D1left); :}
					|
					(DeclarationList_SKIP) {: RESULT=new DeclarationList_SKIP(); :} /* EPSILON */
					;

Declaration ::= (Declaration_Const) ConstDeclaration:C1 SEMICOLON {: RESULT=new Declaration_Const(C1); RESULT.setLine(C1left); :}
				|
				(Declaration_Var) VarDeclaration:V1 SEMICOLON {: RESULT=new Declaration_Var(V1); RESULT.setLine(V1left); :}
				;

/* CONST DECLARATION */

ConstDeclaration ::= (ConstDeclaration) CONST Type:T1 ConstDeclarationList:C2 {: RESULT=new ConstDeclaration(T1, C2); RESULT.setLine(T1left); :}
					 ;
		 
ConstDeclarationList ::= (ConstDeclarationList_One) ConstDeclarationElement:C1 {: RESULT=new ConstDeclarationList_One(C1); RESULT.setLine(C1left); :}
						 |
						 (ConstDeclarationList_Multiple) ConstDeclarationList:C1 COMMA ConstDeclarationElement:C2 {: RESULT=new ConstDeclarationList_Multiple(C1, C2); RESULT.setLine(C1left); :}
						 ;

ConstDeclarationElement ::= (ConstDeclarationElement) IDENT:varName EQUAL ConstValue:C1 {: RESULT=new ConstDeclarationElement(varName, C1); RESULT.setLine(varNameleft); :}
							;
						
ConstValue ::= (ConstValue_INT) INT:I1 {: RESULT=new ConstValue_INT(I1); RESULT.setLine(I1left); :}
			   |
			   (ConstValue_BOOL) BOOL:B1 {: RESULT=new ConstValue_BOOL(B1); RESULT.setLine(B1left); :}
			   |
			   (ConstValue_CHAR) CHAR:C1 {: RESULT=new ConstValue_CHAR(C1); RESULT.setLine(C1left); :}
			   ;

/* VAR DECLARATION */
VarDeclarationListOptional ::= (VarDeclarationListOptional_OneOrMore) VarDeclaration:V1 SEMICOLON VarDeclarationListOptional:V2 {: RESULT=new VarDeclarationListOptional_OneOrMore(V1, V2); RESULT.setLine(V1left); :}
							   |
							   (VarDeclarationListOptional_Skip) {: RESULT=new VarDeclarationListOptional_Skip(); :} /* EPSILON */
							   ;

VarDeclaration ::= (VarDeclaration_VarList) Type:T1 VarList:V2 {: RESULT=new VarDeclaration_VarList(T1, V2); RESULT.setLine(T1left); :}
				   |
				   (VarDeclaration_Error) error {: parser.report_error("Deklaracija promenljive nevalidna! Izvrsen oporavak od greske!", null); :} {: RESULT=new VarDeclaration_Error(); :}
				   ;

VarList ::= (VarList_One) VarListElement:V1 {: RESULT=new VarList_One(V1); RESULT.setLine(V1left); :}
			|
			(VarList_Multiple) VarList:V1 COMMA VarListElement:V2 {: RESULT=new VarList_Multiple(V1, V2); RESULT.setLine(V1left); :}
			;
			
VarListElement ::= (VarListElement) IDENT:elementName VarOrArray:V1 {: RESULT=new VarListElement(elementName, V1); RESULT.setLine(elementNameleft); :}
				   ;
				  
VarOrArray ::= (VarOrArray_Array) LBRACK RBRACK {: RESULT=new VarOrArray_Array(); :}
			   |
			   (VarOrArray_Var) {: RESULT=new VarOrArray_Var(); :} /* EPSILON */
			   ;
	
/* METODE */	

MethodsDeclarationList ::= (MethodsDeclarationList_OneOrMore) MethodsDeclarationList:M1 MethodDeclaration:M2 {: RESULT=new MethodsDeclarationList_OneOrMore(M1, M2); RESULT.setLine(M1left); :}
						   |
						   (MethodsDeclarationList_Skip) {: RESULT=new MethodsDeclarationList_Skip(); :} /* EPSILON */
						   ;
 
MethodDeclaration ::= (MethodDeclaration) MethodDeclarationTypeAndName:M1 LPAREN FormPars:F2 RPAREN VarDeclarationListOptional:V3 LBRACE Statements:S4 RBRACE {: RESULT=new MethodDeclaration(M1, F2, V3, S4); RESULT.setLine(M1left); :}
					  ;
					  
MethodDeclarationTypeAndName ::= (MethodDeclarationTypeAndName_Type) Type:T1 IDENT:methodName {: RESULT=new MethodDeclarationTypeAndName_Type(T1, methodName); RESULT.setLine(T1left); :} 
						  |
						  (MethodDeclarationTypeAndName_Void) VOID IDENT:methodName {: RESULT=new MethodDeclarationTypeAndName_Void(methodName); RESULT.setLine(methodNameleft); :} 
						  ;

FormPars ::= (FormPars_OneOrMore) FormParsList:F1 {: RESULT=new FormPars_OneOrMore(F1); RESULT.setLine(F1left); :}
			 |
			 (FormPars_None) {: RESULT=new FormPars_None(); :} /* EPSILON */
			 |
			 (FormPars_Error) error {: parser.report_error("Navodjenje argumenata funkcije nevalidno! Izvrsen oporavak od greske!", null); :} {: RESULT=new FormPars_Error(); :}
			 ;
			 
FormParsList ::= (FormParsList_Multiple) FormParsList:F1 COMMA Parameter:P2 {: RESULT=new FormParsList_Multiple(F1, P2); RESULT.setLine(F1left); :}
				 |
				 (FormParsList_One) Parameter:P1 {: RESULT=new FormParsList_One(P1); RESULT.setLine(P1left); :}
				 ;
				 
Parameter ::= (Parameter) Type:T1 IDENT:name VarOrArray:V2 {: RESULT=new Parameter(T1, name, V2); RESULT.setLine(T1left); :}
			  ;
			  
Statements ::= (Statements_OneOrMore) Statements:S1 Statement:S2 {: RESULT=new Statements_OneOrMore(S1, S2); RESULT.setLine(S1left); :}
			   |
			   (Statements_None) {: RESULT=new Statements_None(); :} /* EPSILON */
			   ;
			 
Statement ::= (Statement_DesignatorStatement) DesignatorStatement:D1 SEMICOLON {: RESULT=new Statement_DesignatorStatement(D1); RESULT.setLine(D1left); :}
			  |
			  (Statement_Break) BREAK SEMICOLON {: RESULT=new Statement_Break(); :}
			  |
			  (Statement_Continue) CONTINUE SEMICOLON {: RESULT=new Statement_Continue(); :}
			  |
			  (Statement_Return) RETURN ExprOptional:E1 SEMICOLON {: RESULT=new Statement_Return(E1); RESULT.setLine(E1left); :}
			  |
			  (Statement_Read) READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new Statement_Read(D1); RESULT.setLine(D1left); :}
			  |
			  (Statement_Print) PRINT LPAREN Expr:E1 NumConstOptional:N2 RPAREN SEMICOLON {: RESULT=new Statement_Print(E1, N2); RESULT.setLine(E1left); :}
			  |
			  (Statement_If) IF LPAREN Condition:C1 RPAREN Statement:S2 ElseOptional:E3 {: RESULT=new Statement_If(C1, S2, E3); RESULT.setLine(C1left); :}
			  |
			  (Statement_For) FOR LPAREN DesignatorStatementListOptional:D1 SEMICOLON CondFactOptional:C2 SEMICOLON DesignatorStatementListOptional:D3 RPAREN Statement:S4 {: RESULT=new Statement_For(D1, C2, D3, S4); RESULT.setLine(D1left); :}
			  |
			  (Statement_Statements) LBRACE Statements:S1 RBRACE {: RESULT=new Statement_Statements(S1); RESULT.setLine(S1left); :}
			  ;
			  
ElseOptional ::= (ElseOptional_Define) ELSE Statement:S1 {: RESULT=new ElseOptional_Define(S1); RESULT.setLine(S1left); :}
				 |
				 (ElseOptional_Skip) {: RESULT=new ElseOptional_Skip(); :} /* EPSILON */
				 ;
			  
NumConstOptional ::= (NumConstOptional_Define) COMMA INT:I1 {: RESULT=new NumConstOptional_Define(I1); RESULT.setLine(I1left); :}
				     |
				     (NumConstOptional_Skip) {: RESULT=new NumConstOptional_Skip(); :} /* EPSILON */
				     ;
		     
/* CONDITION */

Condition ::= (Condition_One) CondTerm:C1 {: RESULT=new Condition_One(C1); RESULT.setLine(C1left); :}
			  |
			  (Condition_MultipleOR) Condition:C1 OR CondTerm:C2 {: RESULT=new Condition_MultipleOR(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (Condition_Error) error {: parser.report_error("Uslov If-a nevalidan! Izvrsen oporavak od greske!", null); :} {: RESULT=new Condition_Error(); :}
			  ;
				
CondTerm ::= (CondTerm_One) CondFact:C1 {: RESULT=new CondTerm_One(C1); RESULT.setLine(C1left); :}
			 |
			 (CondTerm_MultipleAND) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTerm_MultipleAND(C1, C2); RESULT.setLine(C1left); :}
			 ;

CondFactOptional ::= (CondFact_Define) CondFact:C1 {: RESULT=new CondFact_Define(C1); RESULT.setLine(C1left); :}
					 |
					 (CondFact_Skip) {: RESULT=new CondFact_Skip(); :} /* EPSILON */
					 ;

CondFact ::= (CondFact) Expr:E1 ExprRelopOptional:E2 {: RESULT=new CondFact(E1, E2); RESULT.setLine(E1left); :}
			 ;

/* EXPR */

ExprRelopOptional ::= (ExprRelopOptional_Define) Relop:R1 Expr:E2 {: RESULT=new ExprRelopOptional_Define(R1, E2); RESULT.setLine(R1left); :}
					  |
					  (ExprRelopOptional_Skip) {: RESULT=new ExprRelopOptional_Skip(); :} /* EPSILON */;

ExprOptional ::= (ExprOptional_Define) Expr:E1 {: RESULT=new ExprOptional_Define(E1); RESULT.setLine(E1left); :}
				 |
				 (ExprOptional_Skip) {: RESULT=new ExprOptional_Skip(); :} /* EPSILON */
				 ;
				 
ActParsOptionalBrackets ::= (ActParsOptionalBrackets_Define) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new ActParsOptionalBrackets_Define(A1); RESULT.setLine(A1left); :}
							|
							(ActParsOptionalBrackets_Skip) {: RESULT=new ActParsOptionalBrackets_Skip(); :} /* EPSILON */
							;

ActParsOptional ::= (ActParsOptional_Define) ActPars:A1 {: RESULT=new ActParsOptional_Define(A1); RESULT.setLine(A1left); :}
					|
					(ActParsOptional_Skip) {: RESULT=new ActParsOptional_Skip(); :} /* EPSILON */
					;
		
ActPars ::= (ActPars_One) Expr:E1 {: RESULT=new ActPars_One(E1); RESULT.setLine(E1left); :}
			|
			(ActPars_Multiple) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActPars_Multiple(A1, E2); RESULT.setLine(A1left); :}
			;
		  
Expr ::= (Expr_TermMultiple) Expr:E1 AddOp:A2 Term:T3 {: RESULT=new Expr_TermMultiple(E1, A2, T3); RESULT.setLine(E1left); :}
		 |
		 (Expr_TermOne) Term:T1 {: RESULT=new Expr_TermOne(T1); RESULT.setLine(T1left); :}
		 |
		 (Expr_MinusTermOne) MINUS Term:T1 {: RESULT=new Expr_MinusTermOne(T1); RESULT.setLine(T1left); :}
		 ;

/* TERM */

Term ::= (Term_One) Factor:F1 {: RESULT=new Term_One(F1); RESULT.setLine(F1left); :}
		 |
		 (Term_MultipleMulOp) Term:T1 MulOp:M2 Factor:F3 {: RESULT=new Term_MultipleMulOp(T1, M2, F3); RESULT.setLine(T1left); :};

/* FACTOR */

Factor ::= (Factor_Designator) Designator:D1 ActParsOptionalBrackets:A2 {: RESULT=new Factor_Designator(D1, A2); RESULT.setLine(D1left); :}
		   |
		   (Factor_Const) ConstValue:C1 {: RESULT=new Factor_Const(C1); RESULT.setLine(C1left); :} /* int, bool, char konstanta */
		   |
		   (Factor_Expr) LPAREN Expr:E1 RPAREN {: RESULT=new Factor_Expr(E1); RESULT.setLine(E1left); :}
		   |
		   (Factor_New) NEW Type:T1 FactorNew:F2 {: RESULT=new Factor_New(T1, F2); RESULT.setLine(T1left); :}
		   ;
		   
FactorNew ::= (FactorNew_Array) LBRACK Expr:E1 RBRACK {: RESULT=new FactorNew_Array(E1); RESULT.setLine(E1left); :}
			  |
			  (FactorNew_Object) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new FactorNew_Object(A1); RESULT.setLine(A1left); :}
			  ;

MinusOptional ::= (MinusOptional_Define) MINUS {: RESULT=new MinusOptional_Define(); :}
			      |
			      (MinusOptional_Skip) {: RESULT=new MinusOptional_Skip(); :} /* EPSILON */
			      ;

/* DESIGNATOR */

DesignatorStatement ::= (DesignatorStatement_Designator_With_Options) Designator:D1 DesignatorStatementOptions:D2 {: RESULT=new DesignatorStatement_Designator_With_Options(D1, D2); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_DesignatorList) LBRACK DesignatorListOptional:D1 MUL Designator:D2 RBRACK EQUAL Designator:D3 {: RESULT=new DesignatorStatement_DesignatorList(D1, D2, D3); RESULT.setLine(D1left); :}
						;
					
DesignatorStatementOptions ::= (DesignatorStatementOptions_AssignOpExpr) AssignOp:A1 Expr:E2 {: RESULT=new DesignatorStatementOptions_AssignOpExpr(A1, E2); RESULT.setLine(A1left); :}
							   |
							   (DesignatorStatementOptions_ActPars) LPAREN ActParsOptional:A1 RPAREN {: RESULT=new DesignatorStatementOptions_ActPars(A1); RESULT.setLine(A1left); :}
							   |
							   (DesignatorStatementOptions_Inc) INC {: RESULT=new DesignatorStatementOptions_Inc(); :}
							   |
							   (DesignatorStatementOptions_Dec) DEC {: RESULT=new DesignatorStatementOptions_Dec(); :}
							   |
							   (DesignatorStatementOptions_Error) error {: parser.report_error("Operacija nevalidna! Izvrsen oporavak od greske!", null); :} {: RESULT=new DesignatorStatementOptions_Error(); :}
							   ;
							   
DesignatorListOptional ::= (DesignatorListOptional_Define) DesignatorList:D1 {: RESULT=new DesignatorListOptional_Define(D1); RESULT.setLine(D1left); :}
						   |
						   (DesignatorListOptional_Skip) {: RESULT=new DesignatorListOptional_Skip(); :} /* EPSILON */
						   ;
						
DesignatorList ::= (DesignatorList_One) Designator:D1 COMMA {: RESULT=new DesignatorList_One(D1); RESULT.setLine(D1left); :}
				   |
				   (DesignatorList_Multiple) DesignatorList:D1 COMMA Designator:D2 COMMA {: RESULT=new DesignatorList_Multiple(D1, D2); RESULT.setLine(D1left); :}
				   ; 

DesignatorStatementListOptional ::= (DesignatorStatementListOptional_Define) DesignatorStatementList:D1 {: RESULT=new DesignatorStatementListOptional_Define(D1); RESULT.setLine(D1left); :}
								    |
								    (DesignatorStatementListOptional_Skip) {: RESULT=new DesignatorStatementListOptional_Skip(); :} /* EPSILON */
								    ;

DesignatorStatementList ::= (DesignatorStatementList_More) DesignatorStatementList:D1 COMMA DesignatorStatement:D2 {: RESULT=new DesignatorStatementList_More(D1, D2); RESULT.setLine(D1left); :}
					|
					(DesignatorStatementList_One) DesignatorStatement:D1 {: RESULT=new DesignatorStatementList_One(D1); RESULT.setLine(D1left); :}
					;

Designator ::= (Designator) Var:V1 Members:M2 {: RESULT=new Designator(V1, M2); RESULT.setLine(V1left); :}
			   ;
			   
Members ::= (Members_Define) MemberList:M1 {: RESULT=new Members_Define(M1); RESULT.setLine(M1left); :}
			|
			(Members_Skip) {: RESULT=new Members_Skip(); :} /* EPSILON */
			;
			  
MemberList ::= (MemberList_Multiple) MemberList:M1 Member:M2 {: RESULT=new MemberList_Multiple(M1, M2); RESULT.setLine(M1left); :}
			   |
			   (MemberList_One) Member:M1 {: RESULT=new MemberList_One(M1); RESULT.setLine(M1left); :}
			   ;

Member ::= (Member_Value) DOT IDENT:member {: RESULT=new Member_Value(member); RESULT.setLine(memberleft); :}
		   |
		   (Member_Array) LBRACK Expr:E1 RBRACK {: RESULT=new Member_Array(E1); RESULT.setLine(E1left); :}
		   ;

Label ::= (Label) IDENT:label {: RESULT=new Label(label); RESULT.setLine(labelleft); :}
		 ;

AssignOp ::= (AssignOp_EQUAL) EQUAL {: RESULT=new AssignOp_EQUAL(); :};

Relop ::= (Relop_Double_Equal) DOUBLE_EQUAL {: RESULT=new Relop_Double_Equal(); :}
		  |
		  (Relop_Not_Equal) NOT_EQUAL {: RESULT=new Relop_Not_Equal(); :}
		  |
		  (Relop_GT) GT {: RESULT=new Relop_GT(); :}
		  |
		  (Relop_GTE) GTE {: RESULT=new Relop_GTE(); :}
		  |
		  (Relop_LT) LT {: RESULT=new Relop_LT(); :}
		  |
		  (Relop_LTE) LTE {: RESULT=new Relop_LTE(); :}
		  ;

AddOp ::= (AddOp_Plus) PLUS {: RESULT=new AddOp_Plus(); :}
		  |
		  (AddOp_Minus) MINUS {: RESULT=new AddOp_Minus(); :}
		  ;
			 
MulOp ::= (MulOp_Mul) MUL {: RESULT=new MulOp_Mul(); :}
		  |
		  (MulOp_Div) DIV {: RESULT=new MulOp_Div(); :}
		  |
		  (MulOp_Mod) MOD {: RESULT=new MulOp_Mod(); :}
		  ;
			  


















