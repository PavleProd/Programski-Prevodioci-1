package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID;
terminal EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;

terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACK, RBRACK;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQUAL, DOUBLE_EQUAL, NOT_EQUAL;
terminal GT, GTE, LT, LTE, AND, OR;
terminal INC, DEC;
terminal SEMICOLON, COLON, DOUBLE_COLON, COMMA, DOT;

terminal Integer INT;
terminal Boolean BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program Program;
nonterminal Type Type;
nonterminal Namespace Namespace;
nonterminal Declaration Declaration;
nonterminal DeclarationList DeclarationList;
nonterminal ConstDeclaration ConstDeclaration;
nonterminal ConstDeclarationList ConstDeclarationList;
nonterminal ConstDeclarationElement ConstDeclarationElement;
nonterminal ConstValue ConstValue;
nonterminal VarDeclarationOptional VarDeclarationOptional;
nonterminal VarDeclaration VarDeclaration;
nonterminal VarList VarList;
nonterminal VarListElement VarListElement;
nonterminal VarOrArray VarOrArray;
nonterminal MethodDeclaration MethodDeclaration;
nonterminal MethodDeclarationType MethodDeclarationType;
nonterminal FormPars FormPars;
nonterminal FormParsList FormParsList;
nonterminal Parameter Parameter;
nonterminal Statement Statement;
nonterminal Statements Statements;

nonterminal ExprOptional ExprOptional;
nonterminal Expr Expr;
nonterminal ExprRelopOptional ExprRelopOptional;
nonterminal ActPars ActPars;
nonterminal ActParsOptionalBrackets ActParsOptionalBrackets;
nonterminal Term Term;
nonterminal AddTerms AddTerms;
nonterminal AddTermsList AddTermsList;
nonterminal AddTerm AddTerm;
nonterminal Factor Factor;
nonterminal MulFactors MulFactors;
nonterminal MulFactorsList MulFactorsList;
nonterminal MulFactor MulFactor;
nonterminal MinusOptional MinusOptional;
nonterminal Label Label;
nonterminal AssignOp AssignOp;
nonterminal Relop Relop;
nonterminal AddOp AddOp;
nonterminal MulOp MulOp;
nonterminal Designator Designator;
nonterminal Members Members;
nonterminal MemberList MemberList;
nonterminal Member Member;
nonterminal ArrayOrVarMember ArrayOrVarMember;

nonterminal ElseOptional ElseOptional;
nonterminal NumConstOptional NumConstOptional;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;

precedence left ELSE;

/* PROGRAM */

Program ::= (Program) PROGRAM IDENT:programName Namespace:N1 DeclarationList:D2 LBRACE MethodDeclaration:M3 RBRACE {: RESULT=new Program(programName, N1, D2, M3); RESULT.setLine(programNameleft); :}
			;
			
Type ::= IDENT:typeName {: RESULT=new TypeDerived1(typeName); RESULT.setLine(typeNameleft); :}
		 |
		 Type:T1 DOUBLE_COLON IDENT:typeName {: RESULT=new TypeDerived2(T1, typeName); RESULT.setLine(T1left); :}
		 ;

Namespace ::= NAMESPACE IDENT:namespaceName LBRACE DeclarationList:D1 LBRACE MethodDeclaration:M2 RBRACE RBRACE {: RESULT=new NamespaceDerived1(namespaceName, D1, M2); RESULT.setLine(namespaceNameleft); :}
			  | {: RESULT=new NamespaceDerived2(); :}
			  /* EPSILON */
			  ;

DeclarationList ::= DeclarationList:D1 Declaration:D2 {: RESULT=new DeclarationListDerived1(D1, D2); RESULT.setLine(D1left); :}
					| {: RESULT=new DeclarationListDerived2(); :} /* EPSILON */
					;

Declaration ::= ConstDeclaration:C1 SEMICOLON {: RESULT=new DeclarationDerived1(C1); RESULT.setLine(C1left); :}
				|
				VarDeclaration:V1 SEMICOLON {: RESULT=new DeclarationDerived2(V1); RESULT.setLine(V1left); :}
				;

/* CONST DECLARATION */

ConstDeclaration ::= CONST Type:T1 ConstDeclarationList:C2 {: RESULT=new ConstDeclarationDerived1(T1, C2); RESULT.setLine(T1left); :}
					 ;
		 
ConstDeclarationList ::= ConstDeclarationElement:C1 {: RESULT=new ConstDeclarationListDerived1(C1); RESULT.setLine(C1left); :}
						 |
						 ConstDeclarationList:C1 COMMA ConstDeclarationElement:C2 {: RESULT=new ConstDeclarationListDerived2(C1, C2); RESULT.setLine(C1left); :}
						 ;

ConstDeclarationElement ::= IDENT:varName EQUAL ConstValue:C1 {: RESULT=new ConstDeclarationElementDerived1(varName, C1); RESULT.setLine(varNameleft); :}
							;
						
ConstValue ::= INT:I1 {: RESULT=new ConstValueDerived1(I1); RESULT.setLine(I1left); :}
			   |
			   BOOL:B1 {: RESULT=new ConstValueDerived2(B1); RESULT.setLine(B1left); :}
			   |
			   CHAR:C1 {: RESULT=new ConstValueDerived3(C1); RESULT.setLine(C1left); :}
			   ;

/* VAR DECLARATION */
VarDeclarationOptional ::= VarDeclaration:V1 {: RESULT=new VarDeclarationOptionalDerived1(V1); RESULT.setLine(V1left); :}
						   | {: RESULT=new VarDeclarationOptionalDerived2(); :}
						   /* EPSILON */
						   ;

VarDeclaration ::= Type:T1 VarList:V2 {: RESULT=new VarDeclarationDerived1(T1, V2); RESULT.setLine(T1left); :}
				   ;

VarList ::= VarListElement:V1 {: RESULT=new VarListDerived1(V1); RESULT.setLine(V1left); :}
			|
			VarList:V1 COMMA VarListElement:V2 {: RESULT=new VarListDerived2(V1, V2); RESULT.setLine(V1left); :}
			;
			
VarListElement ::= IDENT:elementName VarOrArray:V1 {: RESULT=new VarListElementDerived1(elementName, V1); RESULT.setLine(elementNameleft); :}
				   ;
				  
VarOrArray ::= LBRACK RBRACK {: RESULT=new VarOrArrayDerived1(); :}
			   | {: RESULT=new VarOrArrayDerived2(); :}
			   /* EPSILON */
			   ;
	
/* METODE */	
		   
MethodDeclaration ::= MethodDeclarationType:M1 IDENT:methodName LPAREN FormPars:F2 RPAREN VarDeclarationOptional:V3 LBRACE Statements:S4 RBRACE {: RESULT=new MethodDeclarationDerived1(M1, methodName, F2, V3, S4); RESULT.setLine(M1left); :}
					  | {: RESULT=new MethodDeclarationDerived2(); :}
					  /* EPSILON */
					  ;
					  
MethodDeclarationType ::= Type:T1 {: RESULT=new MethodDeclarationTypeDerived1(T1); RESULT.setLine(T1left); :}
						  |
						  VOID {: RESULT=new MethodDeclarationTypeDerived2(); :}
						  ;

FormPars ::= FormParsList:F1 {: RESULT=new FormParsDerived1(F1); RESULT.setLine(F1left); :}
			 | {: RESULT=new FormParsDerived2(); :}
			 /* EPSILON */
			 ;
			 
FormParsList ::= FormParsList:F1 COMMA Parameter:P2 {: RESULT=new FormParsListDerived1(F1, P2); RESULT.setLine(F1left); :}
				 |
				 Parameter:P1 {: RESULT=new FormParsListDerived2(P1); RESULT.setLine(P1left); :}
				 ;
			 
Parameter ::= Type:T1 VarListElement:V2 {: RESULT=new ParameterDerived1(T1, V2); RESULT.setLine(T1left); :}
			  ;
			  
Statements ::= Statements:S1 Statement:S2 {: RESULT=new StatementsDerived1(S1, S2); RESULT.setLine(S1left); :}
			   | {: RESULT=new StatementsDerived2(); :}
			   /* EPSILON */
			   ;
			 
Statement ::= BREAK SEMICOLON {: RESULT=new StatementDerived1(); :}
			  |
			  CONTINUE SEMICOLON {: RESULT=new StatementDerived2(); :}
			  |
			  RETURN ExprOptional:E1 SEMICOLON {: RESULT=new StatementDerived3(E1); RESULT.setLine(E1left); :}
			  |
			  READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new StatementDerived4(D1); RESULT.setLine(D1left); :}
			  |
			  PRINT LPAREN Expr:E1 NumConstOptional:N2 RPAREN SEMICOLON {: RESULT=new StatementDerived5(E1, N2); RESULT.setLine(E1left); :}
			  |
			  IF LPAREN Condition:C1 RPAREN Statement:S2 ElseOptional:E3 {: RESULT=new StatementDerived6(C1, S2, E3); RESULT.setLine(C1left); :}
			  ;
			  
ElseOptional ::= ELSE Statement:S1 {: RESULT=new ElseOptionalDerived1(S1); RESULT.setLine(S1left); :}
				 | {: RESULT=new ElseOptionalDerived2(); :}
				 /* EPSILON */
				 ;
			  
NumConstOptional ::= COMMA INT:I1 {: RESULT=new NumConstOptionalDerived1(I1); RESULT.setLine(I1left); :}
				     | {: RESULT=new NumConstOptionalDerived2(); :}
				     /* EPSILON */
				     ;
		     
/* CONDITION */

Condition ::= CondTerm:C1 {: RESULT=new ConditionDerived1(C1); RESULT.setLine(C1left); :}
			  |
			  Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionDerived2(C1, C2); RESULT.setLine(C1left); :}
			  ;
				
CondTerm ::= CondFact:C1 {: RESULT=new CondTermDerived1(C1); RESULT.setLine(C1left); :}
			 |
			 CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermDerived2(C1, C2); RESULT.setLine(C1left); :}
			 ;

CondFact ::= Expr:E1 ExprRelopOptional:E2 {: RESULT=new CondFactDerived1(E1, E2); RESULT.setLine(E1left); :}
			 ;

/* EXPR */

ExprRelopOptional ::= Relop:R1 Expr:E2 {: RESULT=new ExprRelopOptionalDerived1(R1, E2); RESULT.setLine(R1left); :}
					  | {: RESULT=new ExprRelopOptionalDerived2(); :}
					  /* EPSILON */;

ExprOptional ::= Expr:E1 {: RESULT=new ExprOptionalDerived1(E1); RESULT.setLine(E1left); :}
				 | {: RESULT=new ExprOptionalDerived2(); :}
				 /* EPSILON */
				 ;
				 
ActParsOptionalBrackets ::= LPAREN ActPars:A1 RPAREN {: RESULT=new ActParsOptionalBracketsDerived1(A1); RESULT.setLine(A1left); :}
							| {: RESULT=new ActParsOptionalBracketsDerived2(); :}
							/* EPSILON */
							;
							
ActPars ::= Expr:E1 {: RESULT=new ActParsDerived1(E1); RESULT.setLine(E1left); :}
			|
			ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParsDerived2(A1, E2); RESULT.setLine(A1left); :}
			;
		  
Expr ::= MinusOptional:M1 Term:T2 AddTerms:A3 {: RESULT=new ExprDerived1(M1, T2, A3); RESULT.setLine(M1left); :}
		 ;

/* TERM */

Term ::= Factor:F1 MulFactors:M2 {: RESULT=new TermDerived1(F1, M2); RESULT.setLine(F1left); :}
		;
		
AddTerms ::= AddTermsList:A1 {: RESULT=new AddTermsDerived1(A1); RESULT.setLine(A1left); :}
			 | {: RESULT=new AddTermsDerived2(); :}
			 /* Epsilon */
			 ;

AddTermsList ::= AddTermsList:A1 AddTerm:A2 {: RESULT=new AddTermsListDerived1(A1, A2); RESULT.setLine(A1left); :}
				 |
				 AddTerm:A1 {: RESULT=new AddTermsListDerived2(A1); RESULT.setLine(A1left); :}
				 ;
				 
AddTerm ::= AddOp:A1 Term:T2 {: RESULT=new AddTermDerived1(A1, T2); RESULT.setLine(A1left); :}
			;

/* FACTOR */

Factor ::= Designator:D1 ActParsOptionalBrackets:A2 {: RESULT=new FactorDerived1(D1, A2); RESULT.setLine(D1left); :}
		   |
		   ConstValue:C1 {: RESULT=new FactorDerived2(C1); RESULT.setLine(C1left); :} /* int, bool, char konstanta */
		   |
		   LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived3(E1); RESULT.setLine(E1left); :}
		   ;
	
MulFactors ::= MulFactorsList:M1 {: RESULT=new MulFactorsDerived1(M1); RESULT.setLine(M1left); :}
			 | {: RESULT=new MulFactorsDerived2(); :}
			 /* Epsilon */
			 ;

MulFactorsList ::= MulFactorsList:M1 MulFactor:M2 {: RESULT=new MulFactorsListDerived1(M1, M2); RESULT.setLine(M1left); :}
				 |
				 MulFactor:M1 {: RESULT=new MulFactorsListDerived2(M1); RESULT.setLine(M1left); :}
				 ;
				 
MulFactor ::= MulOp:M1 Factor:F2 {: RESULT=new MulFactorDerived1(M1, F2); RESULT.setLine(M1left); :}
			;

MinusOptional ::= MINUS {: RESULT=new MinusOptionalDerived1(); :}
			      | {: RESULT=new MinusOptionalDerived2(); :}
			      /* EPSILON */
			      ;

/* DESIGNATOR */

Designator ::= Type:T1 Members:M2 {: RESULT=new DesignatorDerived1(T1, M2); RESULT.setLine(T1left); :}
			   ;
			   
Members ::= MemberList:M1 {: RESULT=new MembersDerived1(M1); RESULT.setLine(M1left); :}
			| {: RESULT=new MembersDerived2(); :}
			/* EPSILON */
			;
			  
MemberList ::= MemberList:M1 Member:M2 {: RESULT=new MemberListDerived1(M1, M2); RESULT.setLine(M1left); :}
			   |
			   Member:M1 {: RESULT=new MemberListDerived2(M1); RESULT.setLine(M1left); :}
			   ;

Member ::= DOT ArrayOrVarMember:A1 {: RESULT=new MemberDerived1(A1); RESULT.setLine(A1left); :}
		   ;
		   
ArrayOrVarMember ::= IDENT:varValue {: RESULT=new ArrayOrVarMemberDerived1(varValue); RESULT.setLine(varValueleft); :}
					 |
					 LBRACK Expr:E1 RBRACK {: RESULT=new ArrayOrVarMemberDerived2(E1); RESULT.setLine(E1left); :}
					 ;

Label ::= IDENT:label {: RESULT=new LabelDerived1(label); RESULT.setLine(labelleft); :}
		 ;

AssignOp ::= EQUAL {: RESULT=new AssignOpDerived1(); :};

Relop ::= DOUBLE_EQUAL {: RESULT=new RelopDerived1(); :}
		  |
		  NOT_EQUAL {: RESULT=new RelopDerived2(); :}
		  |
		  GT {: RESULT=new RelopDerived3(); :}
		  |
		  GTE {: RESULT=new RelopDerived4(); :}
		  |
		  LT {: RESULT=new RelopDerived5(); :}
		  |
		  LTE {: RESULT=new RelopDerived6(); :}
		  ;

AddOp ::= PLUS {: RESULT=new AddOpDerived1(); :}
		  |
		  MINUS {: RESULT=new AddOpDerived2(); :}
		  ;
			 
MulOp ::= MUL {: RESULT=new MulOpDerived1(); :}
		  |
		  DIV {: RESULT=new MulOpDerived2(); :}
		  |
		  MOD {: RESULT=new MulOpDerived3(); :}
		  ;
			  


















